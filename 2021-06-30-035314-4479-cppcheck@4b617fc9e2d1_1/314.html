
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cppcheck - HTML report - clib (cppcheck 2.3-1)</title>
    <link rel="stylesheet" href="style.css">
    <style>
pre { line-height: 125%; margin: 0; }
td.linenos pre { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; }
span.linenos { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; }
td.linenos pre.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight { background: #ffffff; }
.highlight .c { color: #888888 } /* Comment */
.highlight .err { color: #FF0000; background-color: #FFAAAA } /* Error */
.highlight .k { color: #008800; font-weight: bold } /* Keyword */
.highlight .o { color: #333333 } /* Operator */
.highlight .ch { color: #888888 } /* Comment.Hashbang */
.highlight .cm { color: #888888 } /* Comment.Multiline */
.highlight .cp { color: #557799 } /* Comment.Preproc */
.highlight .cpf { color: #888888 } /* Comment.PreprocFile */
.highlight .c1 { color: #888888 } /* Comment.Single */
.highlight .cs { color: #cc0000; font-weight: bold } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008800; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008800; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008800; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #003388; font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: #008800; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #333399; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #6600EE; font-weight: bold } /* Literal.Number */
.highlight .s { background-color: #fff0f0 } /* Literal.String */
.highlight .na { color: #0000CC } /* Name.Attribute */
.highlight .nb { color: #007020 } /* Name.Builtin */
.highlight .nc { color: #BB0066; font-weight: bold } /* Name.Class */
.highlight .no { color: #003366; font-weight: bold } /* Name.Constant */
.highlight .nd { color: #555555; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #880000; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #FF0000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0066BB; font-weight: bold } /* Name.Function */
.highlight .nl { color: #997700; font-weight: bold } /* Name.Label */
.highlight .nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #007700 } /* Name.Tag */
.highlight .nv { color: #996633 } /* Name.Variable */
.highlight .ow { color: #000000; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #6600EE; font-weight: bold } /* Literal.Number.Bin */
.highlight .mf { color: #6600EE; font-weight: bold } /* Literal.Number.Float */
.highlight .mh { color: #005588; font-weight: bold } /* Literal.Number.Hex */
.highlight .mi { color: #0000DD; font-weight: bold } /* Literal.Number.Integer */
.highlight .mo { color: #4400EE; font-weight: bold } /* Literal.Number.Oct */
.highlight .sa { background-color: #fff0f0 } /* Literal.String.Affix */
.highlight .sb { background-color: #fff0f0 } /* Literal.String.Backtick */
.highlight .sc { color: #0044DD } /* Literal.String.Char */
.highlight .dl { background-color: #fff0f0 } /* Literal.String.Delimiter */
.highlight .sd { color: #DD4422 } /* Literal.String.Doc */
.highlight .s2 { background-color: #fff0f0 } /* Literal.String.Double */
.highlight .se { color: #666666; font-weight: bold; background-color: #fff0f0 } /* Literal.String.Escape */
.highlight .sh { background-color: #fff0f0 } /* Literal.String.Heredoc */
.highlight .si { background-color: #eeeeee } /* Literal.String.Interpol */
.highlight .sx { color: #DD2200; background-color: #fff0f0 } /* Literal.String.Other */
.highlight .sr { color: #000000; background-color: #fff0ff } /* Literal.String.Regex */
.highlight .s1 { background-color: #fff0f0 } /* Literal.String.Single */
.highlight .ss { color: #AA6600 } /* Literal.String.Symbol */
.highlight .bp { color: #007020 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0066BB; font-weight: bold } /* Name.Function.Magic */
.highlight .vc { color: #336699 } /* Name.Variable.Class */
.highlight .vg { color: #dd7700; font-weight: bold } /* Name.Variable.Global */
.highlight .vi { color: #3333BB } /* Name.Variable.Instance */
.highlight .vm { color: #996633 } /* Name.Variable.Magic */
.highlight .il { color: #0000DD; font-weight: bold } /* Literal.Number.Integer.Long */
    </style>
    <script>
      function getStyle(el, styleProp) {
        var y;

        if (el.currentStyle) {
          y = el.currentStyle[styleProp];
        } else if (window.getComputedStyle) {
          y = document.defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);
        }

        return y;
      }

      function toggle() {
        var el = this.expandable_content;
        var mark = this.expandable_marker;

        if (el.style.display === "block") {
          el.style.display = "none";
          mark.textContent = "[+]";
        } else {
          el.style.display = "block";
          mark.textContent = "[-]";
        }
      }

      function initExpandables() {
        var elements = document.querySelectorAll(".expandable");

        for (var i = 0, len = elements.length; i < len; i++) {
          var el = elements[i];
          var clickable = el.querySelector("span");
          var marker = clickable.querySelector(".marker");
          var content = el.querySelector(".content");
          var width = clickable.clientWidth - parseInt(getStyle(content, "padding-left")) - parseInt(getStyle(content, "padding-right"));
          content.style.width = width + "px";
          clickable.expandable_content = content;
          clickable.expandable_marker = marker;
          clickable.addEventListener("click", toggle);
        }
      }

      function toggleDisplay(id) {
        var elements = document.querySelectorAll("." + id);

        for (var i = 0, len = elements.length; i < len; i++) {
          elements[i].classList.toggle("d-none");
        }
      }

      function toggleAll() {
        var elements = document.querySelectorAll("input");

        // starting from 1 since 0 is the "toggle all" input
        for (var i = 1, len = elements.length; i < len; i++) {
          var el = elements[i];

          if (el.checked) {
            el.checked = false;
          } else {
            el.checked = true;
          }

          toggleDisplay(el.id);
        }
      }
      window.addEventListener("load", initExpandables);
    </script>
  </head>
  <body>
    <div id="header" class="header">
      <h1>Cppcheck report - clib (cppcheck 2.3-1): glib/gthread.c</h1>
    </div>
    <div class="wrapper">
      <div id="menu">
       <p id="filename"><a href="index.html">Defects:</a> gthread.c</p>
<a href="314.html#line-0"> toomanyconfigs 0</a><a href="314.html#line-0"> noValidConfiguration 0</a>
    </div>
    <div id="content">
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>   1
   2
   3
   4
   5
   6
   7
   8
   9
  10
  11
  12
  13
  14
  15
  16
  17
  18
  19
  20
  21
  22
  23
  24
  25
  26
  27
  28
  29
  30
  31
  32
  33
  34
  35
  36
  37
  38
  39
  40
  41
  42
  43
  44
  45
  46
  47
  48
  49
  50
  51
  52
  53
  54
  55
  56
  57
  58
  59
  60
  61
  62
  63
  64
  65
  66
  67
  68
  69
  70
  71
  72
  73
  74
  75
  76
  77
  78
  79
  80
  81
  82
  83
  84
  85
  86
  87
  88
  89
  90
  91
  92
  93
  94
  95
  96
  97
  98
  99
 100
 101
 102
 103
 104
 105
 106
 107
 108
 109
 110
 111
 112
 113
 114
 115
 116
 117
 118
 119
 120
 121
 122
 123
 124
 125
 126
 127
 128
 129
 130
 131
 132
 133
 134
 135
 136
 137
 138
 139
 140
 141
 142
 143
 144
 145
 146
 147
 148
 149
 150
 151
 152
 153
 154
 155
 156
 157
 158
 159
 160
 161
 162
 163
 164
 165
 166
 167
 168
 169
 170
 171
 172
 173
 174
 175
 176
 177
 178
 179
 180
 181
 182
 183
 184
 185
 186
 187
 188
 189
 190
 191
 192
 193
 194
 195
 196
 197
 198
 199
 200
 201
 202
 203
 204
 205
 206
 207
 208
 209
 210
 211
 212
 213
 214
 215
 216
 217
 218
 219
 220
 221
 222
 223
 224
 225
 226
 227
 228
 229
 230
 231
 232
 233
 234
 235
 236
 237
 238
 239
 240
 241
 242
 243
 244
 245
 246
 247
 248
 249
 250
 251
 252
 253
 254
 255
 256
 257
 258
 259
 260
 261
 262
 263
 264
 265
 266
 267
 268
 269
 270
 271
 272
 273
 274
 275
 276
 277
 278
 279
 280
 281
 282
 283
 284
 285
 286
 287
 288
 289
 290
 291
 292
 293
 294
 295
 296
 297
 298
 299
 300
 301
 302
 303
 304
 305
 306
 307
 308
 309
 310
 311
 312
 313
 314
 315
 316
 317
 318
 319
 320
 321
 322
 323
 324
 325
 326
 327
 328
 329
 330
 331
 332
 333
 334
 335
 336
 337
 338
 339
 340
 341
 342
 343
 344
 345
 346
 347
 348
 349
 350
 351
 352
 353
 354
 355
 356
 357
 358
 359
 360
 361
 362
 363
 364
 365
 366
 367
 368
 369
 370
 371
 372
 373
 374
 375
 376
 377
 378
 379
 380
 381
 382
 383
 384
 385
 386
 387
 388
 389
 390
 391
 392
 393
 394
 395
 396
 397
 398
 399
 400
 401
 402
 403
 404
 405
 406
 407
 408
 409
 410
 411
 412
 413
 414
 415
 416
 417
 418
 419
 420
 421
 422
 423
 424
 425
 426
 427
 428
 429
 430
 431
 432
 433
 434
 435
 436
 437
 438
 439
 440
 441
 442
 443
 444
 445
 446
 447
 448
 449
 450
 451
 452
 453
 454
 455
 456
 457
 458
 459
 460
 461
 462
 463
 464
 465
 466
 467
 468
 469
 470
 471
 472
 473
 474
 475
 476
 477
 478
 479
 480
 481
 482
 483
 484
 485
 486
 487
 488
 489
 490
 491
 492
 493
 494
 495
 496
 497
 498
 499
 500
 501
 502
 503
 504
 505
 506
 507
 508
 509
 510
 511
 512
 513
 514
 515
 516
 517
 518
 519
 520
 521
 522
 523
 524
 525
 526
 527
 528
 529
 530
 531
 532
 533
 534
 535
 536
 537
 538
 539
 540
 541
 542
 543
 544
 545
 546
 547
 548
 549
 550
 551
 552
 553
 554
 555
 556
 557
 558
 559
 560
 561
 562
 563
 564
 565
 566
 567
 568
 569
 570
 571
 572
 573
 574
 575
 576
 577
 578
 579
 580
 581
 582
 583
 584
 585
 586
 587
 588
 589
 590
 591
 592
 593
 594
 595
 596
 597
 598
 599
 600
 601
 602
 603
 604
 605
 606
 607
 608
 609
 610
 611
 612
 613
 614
 615
 616
 617
 618
 619
 620
 621
 622
 623
 624
 625
 626
 627
 628
 629
 630
 631
 632
 633
 634
 635
 636
 637
 638
 639
 640
 641
 642
 643
 644
 645
 646
 647
 648
 649
 650
 651
 652
 653
 654
 655
 656
 657
 658
 659
 660
 661
 662
 663
 664
 665
 666
 667
 668
 669
 670
 671
 672
 673
 674
 675
 676
 677
 678
 679
 680
 681
 682
 683
 684
 685
 686
 687
 688
 689
 690
 691
 692
 693
 694
 695
 696
 697
 698
 699
 700
 701
 702
 703
 704
 705
 706
 707
 708
 709
 710
 711
 712
 713
 714
 715
 716
 717
 718
 719
 720
 721
 722
 723
 724
 725
 726
 727
 728
 729
 730
 731
 732
 733
 734
 735
 736
 737
 738
 739
 740
 741
 742
 743
 744
 745
 746
 747
 748
 749
 750
 751
 752
 753
 754
 755
 756
 757
 758
 759
 760
 761
 762
 763
 764
 765
 766
 767
 768
 769
 770
 771
 772
 773
 774
 775
 776
 777
 778
 779
 780
 781
 782
 783
 784
 785
 786
 787
 788
 789
 790
 791
 792
 793
 794
 795
 796
 797
 798
 799
 800
 801
 802
 803
 804
 805
 806
 807
 808
 809
 810
 811
 812
 813
 814
 815
 816
 817
 818
 819
 820
 821
 822
 823
 824
 825
 826
 827
 828
 829
 830
 831
 832
 833
 834
 835
 836
 837
 838
 839
 840
 841
 842
 843
 844
 845
 846
 847
 848
 849
 850
 851
 852
 853
 854
 855
 856
 857
 858
 859
 860
 861
 862
 863
 864
 865
 866
 867
 868
 869
 870
 871
 872
 873
 874
 875
 876
 877
 878
 879
 880
 881
 882
 883
 884
 885
 886
 887
 888
 889
 890
 891
 892
 893
 894
 895
 896
 897
 898
 899
 900
 901
 902
 903
 904
 905
 906
 907
 908
 909
 910
 911
 912
 913
 914
 915
 916
 917
 918
 919
 920
 921
 922
 923
 924
 925
 926
 927
 928
 929
 930
 931
 932
 933
 934
 935
 936
 937
 938
 939
 940
 941
 942
 943
 944
 945
 946
 947
 948
 949
 950
 951
 952
 953
 954
 955
 956
 957
 958
 959
 960
 961
 962
 963
 964
 965
 966
 967
 968
 969
 970
 971
 972
 973
 974
 975
 976
 977
 978
 979
 980
 981
 982
 983
 984
 985
 986
 987
 988
 989
 990
 991
 992
 993
 994
 995
 996
 997
 998
 999
1000
1001
1002
1003
1004
1005
1006
1007
1008
1009
1010
1011
1012
1013
1014
1015
1016
1017
1018
1019
1020
1021
1022
1023
1024
1025
1026
1027
1028
1029
1030
1031
1032
1033
1034
1035
1036
1037
1038
1039
1040
1041
1042
1043
1044
1045
1046
1047
1048
1049
1050
1051
1052
1053
1054
1055
1056
1057
1058
1059
1060
1061
1062
1063
1064
1065
1066
1067
1068
1069
1070
1071
1072
1073
1074
1075
1076
1077
1078
1079
1080
1081
1082
1083
1084
1085
1086
1087
1088
1089
1090
1091
1092
1093
1094
1095
1096
1097
1098
1099
1100
1101
1102
1103
1104
1105
1106
1107
1108
1109
1110
1111
1112
1113
1114</pre></div></td><td class="code"><div class="highlight"><pre><span></span><a name="line-1"></a><span class="cm">/* GLIB - Library of useful routines for C programming</span>
<a name="line-2"></a><span class="cm"> * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald</span>
<a name="line-3"></a><span class="cm"> *</span>
<a name="line-4"></a><span class="cm"> * gthread.c: MT safety related functions</span>
<a name="line-5"></a><span class="cm"> * Copyright 1998 Sebastian Wilhelmi; University of Karlsruhe</span>
<a name="line-6"></a><span class="cm"> *                Owen Taylor</span>
<a name="line-7"></a><span class="cm"> *</span>
<a name="line-8"></a><span class="cm"> * This library is free software; you can redistribute it and/or</span>
<a name="line-9"></a><span class="cm"> * modify it under the terms of the GNU Lesser General Public</span>
<a name="line-10"></a><span class="cm"> * License as published by the Free Software Foundation; either</span>
<a name="line-11"></a><span class="cm"> * version 2.1 of the License, or (at your option) any later version.</span>
<a name="line-12"></a><span class="cm"> *</span>
<a name="line-13"></a><span class="cm"> * This library is distributed in the hope that it will be useful,</span>
<a name="line-14"></a><span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="line-15"></a><span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU</span>
<a name="line-16"></a><span class="cm"> * Lesser General Public License for more details.</span>
<a name="line-17"></a><span class="cm"> *</span>
<a name="line-18"></a><span class="cm"> * You should have received a copy of the GNU Lesser General Public</span>
<a name="line-19"></a><span class="cm"> * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="line-20"></a><span class="cm"> */</span>
<a name="line-21"></a>
<a name="line-22"></a><span class="cm">/* Prelude {{{1 ----------------------------------------------------------- */</span>
<a name="line-23"></a>
<a name="line-24"></a><span class="cm">/*</span>
<a name="line-25"></a><span class="cm"> * Modified by the GLib Team and others 1997-2000.  See the AUTHORS</span>
<a name="line-26"></a><span class="cm"> * file for a list of people on the GLib Team.  See the ChangeLog</span>
<a name="line-27"></a><span class="cm"> * files for a list of changes.  These files are distributed with</span>
<a name="line-28"></a><span class="cm"> * GLib at ftp://ftp.ctk.org/pub/ctk/.</span>
<a name="line-29"></a><span class="cm"> */</span>
<a name="line-30"></a>
<a name="line-31"></a><span class="cm">/*</span>
<a name="line-32"></a><span class="cm"> * MT safe</span>
<a name="line-33"></a><span class="cm"> */</span>
<a name="line-34"></a>
<a name="line-35"></a><span class="cm">/* implement gthread.h&#39;s inline functions */</span>
<a name="line-36"></a><span class="cp">#define G_IMPLEMENT_INLINES 1</span>
<a name="line-37"></a><span class="cp">#define __G_THREAD_C__</span>
<a name="line-38"></a>
<a name="line-39"></a><span class="cp">#include</span> <span class="cpf">&quot;config.h&quot;</span><span class="cp"></span>
<a name="line-40"></a>
<a name="line-41"></a><span class="cp">#include</span> <span class="cpf">&quot;gthread.h&quot;</span><span class="cp"></span>
<a name="line-42"></a><span class="cp">#include</span> <span class="cpf">&quot;gthreadprivate.h&quot;</span><span class="cp"></span>
<a name="line-43"></a>
<a name="line-44"></a><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<a name="line-45"></a>
<a name="line-46"></a><span class="cp">#ifdef G_OS_UNIX</span>
<a name="line-47"></a><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<a name="line-48"></a><span class="cp">#endif</span>
<a name="line-49"></a>
<a name="line-50"></a><span class="cp">#ifndef G_OS_WIN32</span>
<a name="line-51"></a><span class="cp">#include</span> <span class="cpf">&lt;sys/time.h&gt;</span><span class="cp"></span>
<a name="line-52"></a><span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp"></span>
<a name="line-53"></a><span class="cp">#else</span>
<a name="line-54"></a><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp"></span>
<a name="line-55"></a><span class="cp">#endif </span><span class="cm">/* G_OS_WIN32 */</span><span class="cp"></span>
<a name="line-56"></a>
<a name="line-57"></a><span class="cp">#include</span> <span class="cpf">&quot;gslice.h&quot;</span><span class="cp"></span>
<a name="line-58"></a><span class="cp">#include</span> <span class="cpf">&quot;gstrfuncs.h&quot;</span><span class="cp"></span>
<a name="line-59"></a><span class="cp">#include</span> <span class="cpf">&quot;gtestutils.h&quot;</span><span class="cp"></span>
<a name="line-60"></a><span class="cp">#include</span> <span class="cpf">&quot;glib_trace.h&quot;</span><span class="cp"></span>
<a name="line-61"></a><span class="cp">#include</span> <span class="cpf">&quot;gtrace-private.h&quot;</span><span class="cp"></span>
<a name="line-62"></a>
<a name="line-63"></a><span class="cm">/**</span>
<a name="line-64"></a><span class="cm"> * SECTION:threads</span>
<a name="line-65"></a><span class="cm"> * @title: Threads</span>
<a name="line-66"></a><span class="cm"> * @short_description: portable support for threads, mutexes, locks,</span>
<a name="line-67"></a><span class="cm"> *     conditions and thread private data</span>
<a name="line-68"></a><span class="cm"> * @see_also: #GThreadPool, #GAsyncQueue</span>
<a name="line-69"></a><span class="cm"> *</span>
<a name="line-70"></a><span class="cm"> * Threads act almost like processes, but unlike processes all threads</span>
<a name="line-71"></a><span class="cm"> * of one process share the same memory. This is good, as it provides</span>
<a name="line-72"></a><span class="cm"> * easy communication between the involved threads via this shared</span>
<a name="line-73"></a><span class="cm"> * memory, and it is bad, because strange things (so called</span>
<a name="line-74"></a><span class="cm"> * &quot;Heisenbugs&quot;) might happen if the program is not carefully designed.</span>
<a name="line-75"></a><span class="cm"> * In particular, due to the concurrent nature of threads, no</span>
<a name="line-76"></a><span class="cm"> * assumptions on the order of execution of code running in different</span>
<a name="line-77"></a><span class="cm"> * threads can be made, unless order is explicitly forced by the</span>
<a name="line-78"></a><span class="cm"> * programmer through synchronization primitives.</span>
<a name="line-79"></a><span class="cm"> *</span>
<a name="line-80"></a><span class="cm"> * The aim of the thread-related functions in GLib is to provide a</span>
<a name="line-81"></a><span class="cm"> * portable means for writing multi-threaded software. There are</span>
<a name="line-82"></a><span class="cm"> * primitives for mutexes to protect the access to portions of memory</span>
<a name="line-83"></a><span class="cm"> * (#GMutex, #GRecMutex and #GRWLock). There is a facility to use</span>
<a name="line-84"></a><span class="cm"> * individual bits for locks (g_bit_lock()). There are primitives</span>
<a name="line-85"></a><span class="cm"> * for condition variables to allow synchronization of threads (#GCond).</span>
<a name="line-86"></a><span class="cm"> * There are primitives for thread-private data - data that every</span>
<a name="line-87"></a><span class="cm"> * thread has a private instance of (#GPrivate). There are facilities</span>
<a name="line-88"></a><span class="cm"> * for one-time initialization (#GOnce, g_once_init_enter()). Finally,</span>
<a name="line-89"></a><span class="cm"> * there are primitives to create and manage threads (#GThread).</span>
<a name="line-90"></a><span class="cm"> *</span>
<a name="line-91"></a><span class="cm"> * The GLib threading system used to be initialized with g_thread_init().</span>
<a name="line-92"></a><span class="cm"> * This is no longer necessary. Since version 2.32, the GLib threading</span>
<a name="line-93"></a><span class="cm"> * system is automatically initialized at the start of your program,</span>
<a name="line-94"></a><span class="cm"> * and all thread-creation functions and synchronization primitives</span>
<a name="line-95"></a><span class="cm"> * are available right away.</span>
<a name="line-96"></a><span class="cm"> *</span>
<a name="line-97"></a><span class="cm"> * Note that it is not safe to assume that your program has no threads</span>
<a name="line-98"></a><span class="cm"> * even if you don&#39;t call g_thread_new() yourself. GLib and GIO can</span>
<a name="line-99"></a><span class="cm"> * and will create threads for their own purposes in some cases, such</span>
<a name="line-100"></a><span class="cm"> * as when using g_unix_signal_source_new() or when using GDBus.</span>
<a name="line-101"></a><span class="cm"> *</span>
<a name="line-102"></a><span class="cm"> * Originally, UNIX did not have threads, and therefore some traditional</span>
<a name="line-103"></a><span class="cm"> * UNIX APIs are problematic in threaded programs. Some notable examples</span>
<a name="line-104"></a><span class="cm"> * are</span>
<a name="line-105"></a><span class="cm"> * </span>
<a name="line-106"></a><span class="cm"> * - C library functions that return data in statically allocated</span>
<a name="line-107"></a><span class="cm"> *   buffers, such as strtok() or strerror(). For many of these,</span>
<a name="line-108"></a><span class="cm"> *   there are thread-safe variants with a _r suffix, or you can</span>
<a name="line-109"></a><span class="cm"> *   look at corresponding GLib APIs (like g_strsplit() or g_strerror()).</span>
<a name="line-110"></a><span class="cm"> *</span>
<a name="line-111"></a><span class="cm"> * - The functions setenv() and unsetenv() manipulate the process</span>
<a name="line-112"></a><span class="cm"> *   environment in a not thread-safe way, and may interfere with getenv()</span>
<a name="line-113"></a><span class="cm"> *   calls in other threads. Note that getenv() calls may be hidden behind</span>
<a name="line-114"></a><span class="cm"> *   other APIs. For example, GNU gettext() calls getenv() under the</span>
<a name="line-115"></a><span class="cm"> *   covers. In general, it is best to treat the environment as readonly.</span>
<a name="line-116"></a><span class="cm"> *   If you absolutely have to modify the environment, do it early in</span>
<a name="line-117"></a><span class="cm"> *   main(), when no other threads are around yet.</span>
<a name="line-118"></a><span class="cm"> *</span>
<a name="line-119"></a><span class="cm"> * - The setlocale() function changes the locale for the entire process,</span>
<a name="line-120"></a><span class="cm"> *   affecting all threads. Temporary changes to the locale are often made</span>
<a name="line-121"></a><span class="cm"> *   to change the behavior of string scanning or formatting functions</span>
<a name="line-122"></a><span class="cm"> *   like scanf() or printf(). GLib offers a number of string APIs</span>
<a name="line-123"></a><span class="cm"> *   (like g_ascii_formatd() or g_ascii_strtod()) that can often be</span>
<a name="line-124"></a><span class="cm"> *   used as an alternative. Or you can use the uselocale() function</span>
<a name="line-125"></a><span class="cm"> *   to change the locale only for the current thread.</span>
<a name="line-126"></a><span class="cm"> *</span>
<a name="line-127"></a><span class="cm"> * - The fork() function only takes the calling thread into the child&#39;s</span>
<a name="line-128"></a><span class="cm"> *   copy of the process image. If other threads were executing in critical</span>
<a name="line-129"></a><span class="cm"> *   sections they could have left mutexes locked which could easily</span>
<a name="line-130"></a><span class="cm"> *   cause deadlocks in the new child. For this reason, you should</span>
<a name="line-131"></a><span class="cm"> *   call exit() or exec() as soon as possible in the child and only</span>
<a name="line-132"></a><span class="cm"> *   make signal-safe library calls before that.</span>
<a name="line-133"></a><span class="cm"> *</span>
<a name="line-134"></a><span class="cm"> * - The daemon() function uses fork() in a way contrary to what is</span>
<a name="line-135"></a><span class="cm"> *   described above. It should not be used with GLib programs.</span>
<a name="line-136"></a><span class="cm"> *</span>
<a name="line-137"></a><span class="cm"> * GLib itself is internally completely thread-safe (all global data is</span>
<a name="line-138"></a><span class="cm"> * automatically locked), but individual data structure instances are</span>
<a name="line-139"></a><span class="cm"> * not automatically locked for performance reasons. For example,</span>
<a name="line-140"></a><span class="cm"> * you must coordinate accesses to the same #GHashTable from multiple</span>
<a name="line-141"></a><span class="cm"> * threads. The two notable exceptions from this rule are #GMainLoop</span>
<a name="line-142"></a><span class="cm"> * and #GAsyncQueue, which are thread-safe and need no further</span>
<a name="line-143"></a><span class="cm"> * application-level locking to be accessed from multiple threads.</span>
<a name="line-144"></a><span class="cm"> * Most refcounting functions such as g_object_ref() are also thread-safe.</span>
<a name="line-145"></a><span class="cm"> *</span>
<a name="line-146"></a><span class="cm"> * A common use for #GThreads is to move a long-running blocking operation out</span>
<a name="line-147"></a><span class="cm"> * of the main thread and into a worker thread. For GLib functions, such as</span>
<a name="line-148"></a><span class="cm"> * single GIO operations, this is not necessary, and complicates the code.</span>
<a name="line-149"></a><span class="cm"> * Instead, the `…_async()` version of the function should be used from the main</span>
<a name="line-150"></a><span class="cm"> * thread, eliminating the need for locking and synchronisation between multiple</span>
<a name="line-151"></a><span class="cm"> * threads. If an operation does need to be moved to a worker thread, consider</span>
<a name="line-152"></a><span class="cm"> * using g_task_run_in_thread(), or a #GThreadPool. #GThreadPool is often a</span>
<a name="line-153"></a><span class="cm"> * better choice than #GThread, as it handles thread reuse and task queueing;</span>
<a name="line-154"></a><span class="cm"> * #GTask uses this internally.</span>
<a name="line-155"></a><span class="cm"> *</span>
<a name="line-156"></a><span class="cm"> * However, if multiple blocking operations need to be performed in sequence,</span>
<a name="line-157"></a><span class="cm"> * and it is not possible to use #GTask for them, moving them to a worker thread</span>
<a name="line-158"></a><span class="cm"> * can clarify the code.</span>
<a name="line-159"></a><span class="cm"> */</span>
<a name="line-160"></a>
<a name="line-161"></a><span class="cm">/* G_LOCK Documentation {{{1 ---------------------------------------------- */</span>
<a name="line-162"></a>
<a name="line-163"></a><span class="cm">/**</span>
<a name="line-164"></a><span class="cm"> * G_LOCK_DEFINE:</span>
<a name="line-165"></a><span class="cm"> * @name: the name of the lock</span>
<a name="line-166"></a><span class="cm"> *</span>
<a name="line-167"></a><span class="cm"> * The #G_LOCK_ macros provide a convenient interface to #GMutex.</span>
<a name="line-168"></a><span class="cm"> * #G_LOCK_DEFINE defines a lock. It can appear in any place where</span>
<a name="line-169"></a><span class="cm"> * variable definitions may appear in programs, i.e. in the first block</span>
<a name="line-170"></a><span class="cm"> * of a function or outside of functions. The @name parameter will be</span>
<a name="line-171"></a><span class="cm"> * mangled to get the name of the #GMutex. This means that you</span>
<a name="line-172"></a><span class="cm"> * can use names of existing variables as the parameter - e.g. the name</span>
<a name="line-173"></a><span class="cm"> * of the variable you intend to protect with the lock. Look at our</span>
<a name="line-174"></a><span class="cm"> * give_me_next_number() example using the #G_LOCK macros:</span>
<a name="line-175"></a><span class="cm"> *</span>
<a name="line-176"></a><span class="cm"> * Here is an example for using the #G_LOCK convenience macros:</span>
<a name="line-177"></a><span class="cm"> * |[&lt;!-- language=&quot;C&quot; --&gt; </span>
<a name="line-178"></a><span class="cm"> *   G_LOCK_DEFINE (current_number);</span>
<a name="line-179"></a><span class="cm"> *</span>
<a name="line-180"></a><span class="cm"> *   int</span>
<a name="line-181"></a><span class="cm"> *   give_me_next_number (void)</span>
<a name="line-182"></a><span class="cm"> *   {</span>
<a name="line-183"></a><span class="cm"> *     static int current_number = 0;</span>
<a name="line-184"></a><span class="cm"> *     int ret_val;</span>
<a name="line-185"></a><span class="cm"> *</span>
<a name="line-186"></a><span class="cm"> *     G_LOCK (current_number);</span>
<a name="line-187"></a><span class="cm"> *     ret_val = current_number = calc_next_number (current_number);</span>
<a name="line-188"></a><span class="cm"> *     G_UNLOCK (current_number);</span>
<a name="line-189"></a><span class="cm"> *</span>
<a name="line-190"></a><span class="cm"> *     return ret_val;</span>
<a name="line-191"></a><span class="cm"> *   }</span>
<a name="line-192"></a><span class="cm"> * ]|</span>
<a name="line-193"></a><span class="cm"> */</span>
<a name="line-194"></a>
<a name="line-195"></a><span class="cm">/**</span>
<a name="line-196"></a><span class="cm"> * G_LOCK_DEFINE_STATIC:</span>
<a name="line-197"></a><span class="cm"> * @name: the name of the lock</span>
<a name="line-198"></a><span class="cm"> *</span>
<a name="line-199"></a><span class="cm"> * This works like #G_LOCK_DEFINE, but it creates a static object.</span>
<a name="line-200"></a><span class="cm"> */</span>
<a name="line-201"></a>
<a name="line-202"></a><span class="cm">/**</span>
<a name="line-203"></a><span class="cm"> * G_LOCK_EXTERN:</span>
<a name="line-204"></a><span class="cm"> * @name: the name of the lock</span>
<a name="line-205"></a><span class="cm"> *</span>
<a name="line-206"></a><span class="cm"> * This declares a lock, that is defined with #G_LOCK_DEFINE in another</span>
<a name="line-207"></a><span class="cm"> * module.</span>
<a name="line-208"></a><span class="cm"> */</span>
<a name="line-209"></a>
<a name="line-210"></a><span class="cm">/**</span>
<a name="line-211"></a><span class="cm"> * G_LOCK:</span>
<a name="line-212"></a><span class="cm"> * @name: the name of the lock</span>
<a name="line-213"></a><span class="cm"> *</span>
<a name="line-214"></a><span class="cm"> * Works like g_mutex_lock(), but for a lock defined with</span>
<a name="line-215"></a><span class="cm"> * #G_LOCK_DEFINE.</span>
<a name="line-216"></a><span class="cm"> */</span>
<a name="line-217"></a>
<a name="line-218"></a><span class="cm">/**</span>
<a name="line-219"></a><span class="cm"> * G_TRYLOCK:</span>
<a name="line-220"></a><span class="cm"> * @name: the name of the lock</span>
<a name="line-221"></a><span class="cm"> *</span>
<a name="line-222"></a><span class="cm"> * Works like g_mutex_trylock(), but for a lock defined with</span>
<a name="line-223"></a><span class="cm"> * #G_LOCK_DEFINE.</span>
<a name="line-224"></a><span class="cm"> *</span>
<a name="line-225"></a><span class="cm"> * Returns: %TRUE, if the lock could be locked.</span>
<a name="line-226"></a><span class="cm"> */</span>
<a name="line-227"></a>
<a name="line-228"></a><span class="cm">/**</span>
<a name="line-229"></a><span class="cm"> * G_UNLOCK:</span>
<a name="line-230"></a><span class="cm"> * @name: the name of the lock</span>
<a name="line-231"></a><span class="cm"> *</span>
<a name="line-232"></a><span class="cm"> * Works like g_mutex_unlock(), but for a lock defined with</span>
<a name="line-233"></a><span class="cm"> * #G_LOCK_DEFINE.</span>
<a name="line-234"></a><span class="cm"> */</span>
<a name="line-235"></a>
<a name="line-236"></a><span class="cm">/* GMutex Documentation {{{1 ------------------------------------------ */</span>
<a name="line-237"></a>
<a name="line-238"></a><span class="cm">/**</span>
<a name="line-239"></a><span class="cm"> * GMutex:</span>
<a name="line-240"></a><span class="cm"> *</span>
<a name="line-241"></a><span class="cm"> * The #GMutex struct is an opaque data structure to represent a mutex</span>
<a name="line-242"></a><span class="cm"> * (mutual exclusion). It can be used to protect data against shared</span>
<a name="line-243"></a><span class="cm"> * access.</span>
<a name="line-244"></a><span class="cm"> *</span>
<a name="line-245"></a><span class="cm"> * Take for example the following function:</span>
<a name="line-246"></a><span class="cm"> * |[&lt;!-- language=&quot;C&quot; --&gt; </span>
<a name="line-247"></a><span class="cm"> *   int</span>
<a name="line-248"></a><span class="cm"> *   give_me_next_number (void)</span>
<a name="line-249"></a><span class="cm"> *   {</span>
<a name="line-250"></a><span class="cm"> *     static int current_number = 0;</span>
<a name="line-251"></a><span class="cm"> *</span>
<a name="line-252"></a><span class="cm"> *     // now do a very complicated calculation to calculate the new</span>
<a name="line-253"></a><span class="cm"> *     // number, this might for example be a random number generator</span>
<a name="line-254"></a><span class="cm"> *     current_number = calc_next_number (current_number);</span>
<a name="line-255"></a><span class="cm"> *</span>
<a name="line-256"></a><span class="cm"> *     return current_number;</span>
<a name="line-257"></a><span class="cm"> *   }</span>
<a name="line-258"></a><span class="cm"> * ]|</span>
<a name="line-259"></a><span class="cm"> * It is easy to see that this won&#39;t work in a multi-threaded</span>
<a name="line-260"></a><span class="cm"> * application. There current_number must be protected against shared</span>
<a name="line-261"></a><span class="cm"> * access. A #GMutex can be used as a solution to this problem:</span>
<a name="line-262"></a><span class="cm"> * |[&lt;!-- language=&quot;C&quot; --&gt; </span>
<a name="line-263"></a><span class="cm"> *   int</span>
<a name="line-264"></a><span class="cm"> *   give_me_next_number (void)</span>
<a name="line-265"></a><span class="cm"> *   {</span>
<a name="line-266"></a><span class="cm"> *     static GMutex mutex;</span>
<a name="line-267"></a><span class="cm"> *     static int current_number = 0;</span>
<a name="line-268"></a><span class="cm"> *     int ret_val;</span>
<a name="line-269"></a><span class="cm"> *</span>
<a name="line-270"></a><span class="cm"> *     g_mutex_lock (&amp;mutex);</span>
<a name="line-271"></a><span class="cm"> *     ret_val = current_number = calc_next_number (current_number);</span>
<a name="line-272"></a><span class="cm"> *     g_mutex_unlock (&amp;mutex);</span>
<a name="line-273"></a><span class="cm"> *</span>
<a name="line-274"></a><span class="cm"> *     return ret_val;</span>
<a name="line-275"></a><span class="cm"> *   }</span>
<a name="line-276"></a><span class="cm"> * ]|</span>
<a name="line-277"></a><span class="cm"> * Notice that the #GMutex is not initialised to any particular value.</span>
<a name="line-278"></a><span class="cm"> * Its placement in static storage ensures that it will be initialised</span>
<a name="line-279"></a><span class="cm"> * to all-zeros, which is appropriate.</span>
<a name="line-280"></a><span class="cm"> *</span>
<a name="line-281"></a><span class="cm"> * If a #GMutex is placed in other contexts (eg: embedded in a struct)</span>
<a name="line-282"></a><span class="cm"> * then it must be explicitly initialised using g_mutex_init().</span>
<a name="line-283"></a><span class="cm"> *</span>
<a name="line-284"></a><span class="cm"> * A #GMutex should only be accessed via g_mutex_ functions.</span>
<a name="line-285"></a><span class="cm"> */</span>
<a name="line-286"></a>
<a name="line-287"></a><span class="cm">/* GRecMutex Documentation {{{1 -------------------------------------- */</span>
<a name="line-288"></a>
<a name="line-289"></a><span class="cm">/**</span>
<a name="line-290"></a><span class="cm"> * GRecMutex:</span>
<a name="line-291"></a><span class="cm"> *</span>
<a name="line-292"></a><span class="cm"> * The GRecMutex struct is an opaque data structure to represent a</span>
<a name="line-293"></a><span class="cm"> * recursive mutex. It is similar to a #GMutex with the difference</span>
<a name="line-294"></a><span class="cm"> * that it is possible to lock a GRecMutex multiple times in the same</span>
<a name="line-295"></a><span class="cm"> * thread without deadlock. When doing so, care has to be taken to</span>
<a name="line-296"></a><span class="cm"> * unlock the recursive mutex as often as it has been locked.</span>
<a name="line-297"></a><span class="cm"> *</span>
<a name="line-298"></a><span class="cm"> * If a #GRecMutex is allocated in static storage then it can be used</span>
<a name="line-299"></a><span class="cm"> * without initialisation.  Otherwise, you should call</span>
<a name="line-300"></a><span class="cm"> * g_rec_mutex_init() on it and g_rec_mutex_clear() when done.</span>
<a name="line-301"></a><span class="cm"> *</span>
<a name="line-302"></a><span class="cm"> * A GRecMutex should only be accessed with the</span>
<a name="line-303"></a><span class="cm"> * g_rec_mutex_ functions.</span>
<a name="line-304"></a><span class="cm"> *</span>
<a name="line-305"></a><span class="cm"> * Since: 2.32</span>
<a name="line-306"></a><span class="cm"> */</span>
<a name="line-307"></a>
<a name="line-308"></a><span class="cm">/* GRWLock Documentation {{{1 ---------------------------------------- */</span>
<a name="line-309"></a>
<a name="line-310"></a><span class="cm">/**</span>
<a name="line-311"></a><span class="cm"> * GRWLock:</span>
<a name="line-312"></a><span class="cm"> *</span>
<a name="line-313"></a><span class="cm"> * The GRWLock struct is an opaque data structure to represent a</span>
<a name="line-314"></a><span class="cm"> * reader-writer lock. It is similar to a #GMutex in that it allows</span>
<a name="line-315"></a><span class="cm"> * multiple threads to coordinate access to a shared resource.</span>
<a name="line-316"></a><span class="cm"> *</span>
<a name="line-317"></a><span class="cm"> * The difference to a mutex is that a reader-writer lock discriminates</span>
<a name="line-318"></a><span class="cm"> * between read-only (&#39;reader&#39;) and full (&#39;writer&#39;) access. While only</span>
<a name="line-319"></a><span class="cm"> * one thread at a time is allowed write access (by holding the &#39;writer&#39;</span>
<a name="line-320"></a><span class="cm"> * lock via g_rw_lock_writer_lock()), multiple threads can gain</span>
<a name="line-321"></a><span class="cm"> * simultaneous read-only access (by holding the &#39;reader&#39; lock via</span>
<a name="line-322"></a><span class="cm"> * g_rw_lock_reader_lock()).</span>
<a name="line-323"></a><span class="cm"> *</span>
<a name="line-324"></a><span class="cm"> * It is unspecified whether readers or writers have priority in acquiring the</span>
<a name="line-325"></a><span class="cm"> * lock when a reader already holds the lock and a writer is queued to acquire</span>
<a name="line-326"></a><span class="cm"> * it.</span>
<a name="line-327"></a><span class="cm"> *</span>
<a name="line-328"></a><span class="cm"> * Here is an example for an array with access functions:</span>
<a name="line-329"></a><span class="cm"> * |[&lt;!-- language=&quot;C&quot; --&gt; </span>
<a name="line-330"></a><span class="cm"> *   GRWLock lock;</span>
<a name="line-331"></a><span class="cm"> *   GPtrArray *array;</span>
<a name="line-332"></a><span class="cm"> *</span>
<a name="line-333"></a><span class="cm"> *   gpointer</span>
<a name="line-334"></a><span class="cm"> *   my_array_get (guint index)</span>
<a name="line-335"></a><span class="cm"> *   {</span>
<a name="line-336"></a><span class="cm"> *     gpointer retval = NULL;</span>
<a name="line-337"></a><span class="cm"> *</span>
<a name="line-338"></a><span class="cm"> *     if (!array)</span>
<a name="line-339"></a><span class="cm"> *       return NULL;</span>
<a name="line-340"></a><span class="cm"> *</span>
<a name="line-341"></a><span class="cm"> *     g_rw_lock_reader_lock (&amp;lock);</span>
<a name="line-342"></a><span class="cm"> *     if (index &lt; array-&gt;len)</span>
<a name="line-343"></a><span class="cm"> *       retval = g_ptr_array_index (array, index);</span>
<a name="line-344"></a><span class="cm"> *     g_rw_lock_reader_unlock (&amp;lock);</span>
<a name="line-345"></a><span class="cm"> *</span>
<a name="line-346"></a><span class="cm"> *     return retval;</span>
<a name="line-347"></a><span class="cm"> *   }</span>
<a name="line-348"></a><span class="cm"> *</span>
<a name="line-349"></a><span class="cm"> *   void</span>
<a name="line-350"></a><span class="cm"> *   my_array_set (guint index, gpointer data)</span>
<a name="line-351"></a><span class="cm"> *   {</span>
<a name="line-352"></a><span class="cm"> *     g_rw_lock_writer_lock (&amp;lock);</span>
<a name="line-353"></a><span class="cm"> *</span>
<a name="line-354"></a><span class="cm"> *     if (!array)</span>
<a name="line-355"></a><span class="cm"> *       array = g_ptr_array_new ();</span>
<a name="line-356"></a><span class="cm"> *</span>
<a name="line-357"></a><span class="cm"> *     if (index &gt;= array-&gt;len)</span>
<a name="line-358"></a><span class="cm"> *       g_ptr_array_set_size (array, index+1);</span>
<a name="line-359"></a><span class="cm"> *     g_ptr_array_index (array, index) = data;</span>
<a name="line-360"></a><span class="cm"> *</span>
<a name="line-361"></a><span class="cm"> *     g_rw_lock_writer_unlock (&amp;lock);</span>
<a name="line-362"></a><span class="cm"> *   }</span>
<a name="line-363"></a><span class="cm"> *  ]|</span>
<a name="line-364"></a><span class="cm"> * This example shows an array which can be accessed by many readers</span>
<a name="line-365"></a><span class="cm"> * (the my_array_get() function) simultaneously, whereas the writers</span>
<a name="line-366"></a><span class="cm"> * (the my_array_set() function) will only be allowed one at a time</span>
<a name="line-367"></a><span class="cm"> * and only if no readers currently access the array. This is because</span>
<a name="line-368"></a><span class="cm"> * of the potentially dangerous resizing of the array. Using these</span>
<a name="line-369"></a><span class="cm"> * functions is fully multi-thread safe now.</span>
<a name="line-370"></a><span class="cm"> *</span>
<a name="line-371"></a><span class="cm"> * If a #GRWLock is allocated in static storage then it can be used</span>
<a name="line-372"></a><span class="cm"> * without initialisation.  Otherwise, you should call</span>
<a name="line-373"></a><span class="cm"> * g_rw_lock_init() on it and g_rw_lock_clear() when done.</span>
<a name="line-374"></a><span class="cm"> *</span>
<a name="line-375"></a><span class="cm"> * A GRWLock should only be accessed with the g_rw_lock_ functions.</span>
<a name="line-376"></a><span class="cm"> *</span>
<a name="line-377"></a><span class="cm"> * Since: 2.32</span>
<a name="line-378"></a><span class="cm"> */</span>
<a name="line-379"></a>
<a name="line-380"></a><span class="cm">/* GCond Documentation {{{1 ------------------------------------------ */</span>
<a name="line-381"></a>
<a name="line-382"></a><span class="cm">/**</span>
<a name="line-383"></a><span class="cm"> * GCond:</span>
<a name="line-384"></a><span class="cm"> *</span>
<a name="line-385"></a><span class="cm"> * The #GCond struct is an opaque data structure that represents a</span>
<a name="line-386"></a><span class="cm"> * condition. Threads can block on a #GCond if they find a certain</span>
<a name="line-387"></a><span class="cm"> * condition to be false. If other threads change the state of this</span>
<a name="line-388"></a><span class="cm"> * condition they signal the #GCond, and that causes the waiting</span>
<a name="line-389"></a><span class="cm"> * threads to be woken up.</span>
<a name="line-390"></a><span class="cm"> *</span>
<a name="line-391"></a><span class="cm"> * Consider the following example of a shared variable.  One or more</span>
<a name="line-392"></a><span class="cm"> * threads can wait for data to be published to the variable and when</span>
<a name="line-393"></a><span class="cm"> * another thread publishes the data, it can signal one of the waiting</span>
<a name="line-394"></a><span class="cm"> * threads to wake up to collect the data.</span>
<a name="line-395"></a><span class="cm"> *</span>
<a name="line-396"></a><span class="cm"> * Here is an example for using GCond to block a thread until a condition</span>
<a name="line-397"></a><span class="cm"> * is satisfied:</span>
<a name="line-398"></a><span class="cm"> * |[&lt;!-- language=&quot;C&quot; --&gt; </span>
<a name="line-399"></a><span class="cm"> *   gpointer current_data = NULL;</span>
<a name="line-400"></a><span class="cm"> *   GMutex data_mutex;</span>
<a name="line-401"></a><span class="cm"> *   GCond data_cond;</span>
<a name="line-402"></a><span class="cm"> *</span>
<a name="line-403"></a><span class="cm"> *   void</span>
<a name="line-404"></a><span class="cm"> *   push_data (gpointer data)</span>
<a name="line-405"></a><span class="cm"> *   {</span>
<a name="line-406"></a><span class="cm"> *     g_mutex_lock (&amp;data_mutex);</span>
<a name="line-407"></a><span class="cm"> *     current_data = data;</span>
<a name="line-408"></a><span class="cm"> *     g_cond_signal (&amp;data_cond);</span>
<a name="line-409"></a><span class="cm"> *     g_mutex_unlock (&amp;data_mutex);</span>
<a name="line-410"></a><span class="cm"> *   }</span>
<a name="line-411"></a><span class="cm"> *</span>
<a name="line-412"></a><span class="cm"> *   gpointer</span>
<a name="line-413"></a><span class="cm"> *   pop_data (void)</span>
<a name="line-414"></a><span class="cm"> *   {</span>
<a name="line-415"></a><span class="cm"> *     gpointer data;</span>
<a name="line-416"></a><span class="cm"> *</span>
<a name="line-417"></a><span class="cm"> *     g_mutex_lock (&amp;data_mutex);</span>
<a name="line-418"></a><span class="cm"> *     while (!current_data)</span>
<a name="line-419"></a><span class="cm"> *       g_cond_wait (&amp;data_cond, &amp;data_mutex);</span>
<a name="line-420"></a><span class="cm"> *     data = current_data;</span>
<a name="line-421"></a><span class="cm"> *     current_data = NULL;</span>
<a name="line-422"></a><span class="cm"> *     g_mutex_unlock (&amp;data_mutex);</span>
<a name="line-423"></a><span class="cm"> *</span>
<a name="line-424"></a><span class="cm"> *     return data;</span>
<a name="line-425"></a><span class="cm"> *   }</span>
<a name="line-426"></a><span class="cm"> * ]|</span>
<a name="line-427"></a><span class="cm"> * Whenever a thread calls pop_data() now, it will wait until</span>
<a name="line-428"></a><span class="cm"> * current_data is non-%NULL, i.e. until some other thread</span>
<a name="line-429"></a><span class="cm"> * has called push_data().</span>
<a name="line-430"></a><span class="cm"> *</span>
<a name="line-431"></a><span class="cm"> * The example shows that use of a condition variable must always be</span>
<a name="line-432"></a><span class="cm"> * paired with a mutex.  Without the use of a mutex, there would be a</span>
<a name="line-433"></a><span class="cm"> * race between the check of @current_data by the while loop in</span>
<a name="line-434"></a><span class="cm"> * pop_data() and waiting. Specifically, another thread could set</span>
<a name="line-435"></a><span class="cm"> * @current_data after the check, and signal the cond (with nobody</span>
<a name="line-436"></a><span class="cm"> * waiting on it) before the first thread goes to sleep. #GCond is</span>
<a name="line-437"></a><span class="cm"> * specifically useful for its ability to release the mutex and go</span>
<a name="line-438"></a><span class="cm"> * to sleep atomically.</span>
<a name="line-439"></a><span class="cm"> *</span>
<a name="line-440"></a><span class="cm"> * It is also important to use the g_cond_wait() and g_cond_wait_until()</span>
<a name="line-441"></a><span class="cm"> * functions only inside a loop which checks for the condition to be</span>
<a name="line-442"></a><span class="cm"> * true.  See g_cond_wait() for an explanation of why the condition may</span>
<a name="line-443"></a><span class="cm"> * not be true even after it returns.</span>
<a name="line-444"></a><span class="cm"> *</span>
<a name="line-445"></a><span class="cm"> * If a #GCond is allocated in static storage then it can be used</span>
<a name="line-446"></a><span class="cm"> * without initialisation.  Otherwise, you should call g_cond_init()</span>
<a name="line-447"></a><span class="cm"> * on it and g_cond_clear() when done.</span>
<a name="line-448"></a><span class="cm"> *</span>
<a name="line-449"></a><span class="cm"> * A #GCond should only be accessed via the g_cond_ functions.</span>
<a name="line-450"></a><span class="cm"> */</span>
<a name="line-451"></a>
<a name="line-452"></a><span class="cm">/* GThread Documentation {{{1 ---------------------------------------- */</span>
<a name="line-453"></a>
<a name="line-454"></a><span class="cm">/**</span>
<a name="line-455"></a><span class="cm"> * GThread:</span>
<a name="line-456"></a><span class="cm"> *</span>
<a name="line-457"></a><span class="cm"> * The #GThread struct represents a running thread. This struct</span>
<a name="line-458"></a><span class="cm"> * is returned by g_thread_new() or g_thread_try_new(). You can</span>
<a name="line-459"></a><span class="cm"> * obtain the #GThread struct representing the current thread by</span>
<a name="line-460"></a><span class="cm"> * calling g_thread_self().</span>
<a name="line-461"></a><span class="cm"> *</span>
<a name="line-462"></a><span class="cm"> * GThread is refcounted, see g_thread_ref() and g_thread_unref().</span>
<a name="line-463"></a><span class="cm"> * The thread represented by it holds a reference while it is running,</span>
<a name="line-464"></a><span class="cm"> * and g_thread_join() consumes the reference that it is given, so</span>
<a name="line-465"></a><span class="cm"> * it is normally not necessary to manage GThread references</span>
<a name="line-466"></a><span class="cm"> * explicitly.</span>
<a name="line-467"></a><span class="cm"> *</span>
<a name="line-468"></a><span class="cm"> * The structure is opaque -- none of its fields may be directly</span>
<a name="line-469"></a><span class="cm"> * accessed.</span>
<a name="line-470"></a><span class="cm"> */</span>
<a name="line-471"></a>
<a name="line-472"></a><span class="cm">/**</span>
<a name="line-473"></a><span class="cm"> * GThreadFunc:</span>
<a name="line-474"></a><span class="cm"> * @data: data passed to the thread</span>
<a name="line-475"></a><span class="cm"> *</span>
<a name="line-476"></a><span class="cm"> * Specifies the type of the @func functions passed to g_thread_new()</span>
<a name="line-477"></a><span class="cm"> * or g_thread_try_new().</span>
<a name="line-478"></a><span class="cm"> *</span>
<a name="line-479"></a><span class="cm"> * Returns: the return value of the thread</span>
<a name="line-480"></a><span class="cm"> */</span>
<a name="line-481"></a>
<a name="line-482"></a><span class="cm">/**</span>
<a name="line-483"></a><span class="cm"> * g_thread_supported:</span>
<a name="line-484"></a><span class="cm"> *</span>
<a name="line-485"></a><span class="cm"> * This macro returns %TRUE if the thread system is initialized,</span>
<a name="line-486"></a><span class="cm"> * and %FALSE if it is not.</span>
<a name="line-487"></a><span class="cm"> *</span>
<a name="line-488"></a><span class="cm"> * For language bindings, g_thread_get_initialized() provides</span>
<a name="line-489"></a><span class="cm"> * the same functionality as a function.</span>
<a name="line-490"></a><span class="cm"> *</span>
<a name="line-491"></a><span class="cm"> * Returns: %TRUE, if the thread system is initialized</span>
<a name="line-492"></a><span class="cm"> */</span>
<a name="line-493"></a>
<a name="line-494"></a><span class="cm">/* GThreadError {{{1 ------------------------------------------------------- */</span>
<a name="line-495"></a><span class="cm">/**</span>
<a name="line-496"></a><span class="cm"> * GThreadError:</span>
<a name="line-497"></a><span class="cm"> * @G_THREAD_ERROR_AGAIN: a thread couldn&#39;t be created due to resource</span>
<a name="line-498"></a><span class="cm"> *                        shortage. Try again later.</span>
<a name="line-499"></a><span class="cm"> *</span>
<a name="line-500"></a><span class="cm"> * Possible errors of thread related functions.</span>
<a name="line-501"></a><span class="cm"> **/</span>
<a name="line-502"></a>
<a name="line-503"></a><span class="cm">/**</span>
<a name="line-504"></a><span class="cm"> * G_THREAD_ERROR:</span>
<a name="line-505"></a><span class="cm"> *</span>
<a name="line-506"></a><span class="cm"> * The error domain of the GLib thread subsystem.</span>
<a name="line-507"></a><span class="cm"> **/</span>
<a name="line-508"></a><span class="n">G_DEFINE_QUARK</span> <span class="p">(</span><span class="n">g_thread_error</span><span class="p">,</span> <span class="n">g_thread_error</span><span class="p">)</span>
<a name="line-509"></a>
<a name="line-510"></a><span class="cm">/* Local Data {{{1 -------------------------------------------------------- */</span>
<a name="line-511"></a>
<a name="line-512"></a><span class="k">static</span> <span class="n">GMutex</span>    <span class="n">g_once_mutex</span><span class="p">;</span>
<a name="line-513"></a><span class="k">static</span> <span class="n">GCond</span>     <span class="n">g_once_cond</span><span class="p">;</span>
<a name="line-514"></a><span class="k">static</span> <span class="n">GSList</span>   <span class="o">*</span><span class="n">g_once_init_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<a name="line-515"></a>
<a name="line-516"></a><span class="k">static</span> <span class="k">volatile</span> <span class="n">guint</span> <span class="n">g_thread_n_created_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-517"></a>
<a name="line-518"></a><span class="k">static</span> <span class="kt">void</span> <span class="n">g_thread_cleanup</span> <span class="p">(</span><span class="n">gpointer</span> <span class="n">data</span><span class="p">);</span>
<a name="line-519"></a><span class="k">static</span> <span class="n">GPrivate</span>     <span class="n">g_thread_specific_private</span> <span class="o">=</span> <span class="n">G_PRIVATE_INIT</span> <span class="p">(</span><span class="n">g_thread_cleanup</span><span class="p">);</span>
<a name="line-520"></a>
<a name="line-521"></a><span class="cm">/*</span>
<a name="line-522"></a><span class="cm"> * g_private_set_alloc0:</span>
<a name="line-523"></a><span class="cm"> * @key: a #GPrivate</span>
<a name="line-524"></a><span class="cm"> * @size: size of the allocation, in bytes</span>
<a name="line-525"></a><span class="cm"> *</span>
<a name="line-526"></a><span class="cm"> * Sets the thread local variable @key to have a newly-allocated and zero-filled</span>
<a name="line-527"></a><span class="cm"> * value of given @size, and returns a pointer to that memory. Allocations made</span>
<a name="line-528"></a><span class="cm"> * using this API will be suppressed in valgrind: it is intended to be used for</span>
<a name="line-529"></a><span class="cm"> * one-time allocations which are known to be leaked, such as those for</span>
<a name="line-530"></a><span class="cm"> * per-thread initialisation data. Otherwise, this function behaves the same as</span>
<a name="line-531"></a><span class="cm"> * g_private_set().</span>
<a name="line-532"></a><span class="cm"> *</span>
<a name="line-533"></a><span class="cm"> * Returns: (transfer full): new thread-local heap allocation of size @size</span>
<a name="line-534"></a><span class="cm"> * Since: 2.60</span>
<a name="line-535"></a><span class="cm"> */</span>
<a name="line-536"></a><span class="cm">/*&lt; private &gt;*/</span>
<a name="line-537"></a><span class="n">gpointer</span>
<a name="line-538"></a><span class="nf">g_private_set_alloc0</span> <span class="p">(</span><span class="n">GPrivate</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
<a name="line-539"></a>                      <span class="n">gsize</span>     <span class="n">size</span><span class="p">)</span>
<a name="line-540"></a><span class="p">{</span>
<a name="line-541"></a>  <span class="n">gpointer</span> <span class="n">allocated</span> <span class="o">=</span> <span class="n">g_malloc0</span> <span class="p">(</span><span class="n">size</span><span class="p">);</span>
<a name="line-542"></a>
<a name="line-543"></a>  <span class="n">g_private_set</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">allocated</span><span class="p">);</span>
<a name="line-544"></a>
<a name="line-545"></a>  <span class="k">return</span> <span class="n">g_steal_pointer</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">allocated</span><span class="p">);</span>
<a name="line-546"></a><span class="p">}</span>
<a name="line-547"></a>
<a name="line-548"></a><span class="cm">/* GOnce {{{1 ------------------------------------------------------------- */</span>
<a name="line-549"></a>
<a name="line-550"></a><span class="cm">/**</span>
<a name="line-551"></a><span class="cm"> * GOnce:</span>
<a name="line-552"></a><span class="cm"> * @status: the status of the #GOnce</span>
<a name="line-553"></a><span class="cm"> * @retval: the value returned by the call to the function, if @status</span>
<a name="line-554"></a><span class="cm"> *          is %G_ONCE_STATUS_READY</span>
<a name="line-555"></a><span class="cm"> *</span>
<a name="line-556"></a><span class="cm"> * A #GOnce struct controls a one-time initialization function. Any</span>
<a name="line-557"></a><span class="cm"> * one-time initialization function must have its own unique #GOnce</span>
<a name="line-558"></a><span class="cm"> * struct.</span>
<a name="line-559"></a><span class="cm"> *</span>
<a name="line-560"></a><span class="cm"> * Since: 2.4</span>
<a name="line-561"></a><span class="cm"> */</span>
<a name="line-562"></a>
<a name="line-563"></a><span class="cm">/**</span>
<a name="line-564"></a><span class="cm"> * G_ONCE_INIT:</span>
<a name="line-565"></a><span class="cm"> *</span>
<a name="line-566"></a><span class="cm"> * A #GOnce must be initialized with this macro before it can be used.</span>
<a name="line-567"></a><span class="cm"> *</span>
<a name="line-568"></a><span class="cm"> * |[&lt;!-- language=&quot;C&quot; --&gt; </span>
<a name="line-569"></a><span class="cm"> *   GOnce my_once = G_ONCE_INIT;</span>
<a name="line-570"></a><span class="cm"> * ]|</span>
<a name="line-571"></a><span class="cm"> *</span>
<a name="line-572"></a><span class="cm"> * Since: 2.4</span>
<a name="line-573"></a><span class="cm"> */</span>
<a name="line-574"></a>
<a name="line-575"></a><span class="cm">/**</span>
<a name="line-576"></a><span class="cm"> * GOnceStatus:</span>
<a name="line-577"></a><span class="cm"> * @G_ONCE_STATUS_NOTCALLED: the function has not been called yet.</span>
<a name="line-578"></a><span class="cm"> * @G_ONCE_STATUS_PROGRESS: the function call is currently in progress.</span>
<a name="line-579"></a><span class="cm"> * @G_ONCE_STATUS_READY: the function has been called.</span>
<a name="line-580"></a><span class="cm"> *</span>
<a name="line-581"></a><span class="cm"> * The possible statuses of a one-time initialization function</span>
<a name="line-582"></a><span class="cm"> * controlled by a #GOnce struct.</span>
<a name="line-583"></a><span class="cm"> *</span>
<a name="line-584"></a><span class="cm"> * Since: 2.4</span>
<a name="line-585"></a><span class="cm"> */</span>
<a name="line-586"></a>
<a name="line-587"></a><span class="cm">/**</span>
<a name="line-588"></a><span class="cm"> * g_once:</span>
<a name="line-589"></a><span class="cm"> * @once: a #GOnce structure</span>
<a name="line-590"></a><span class="cm"> * @func: the #GThreadFunc function associated to @once. This function</span>
<a name="line-591"></a><span class="cm"> *        is called only once, regardless of the number of times it and</span>
<a name="line-592"></a><span class="cm"> *        its associated #GOnce struct are passed to g_once().</span>
<a name="line-593"></a><span class="cm"> * @arg: data to be passed to @func</span>
<a name="line-594"></a><span class="cm"> *</span>
<a name="line-595"></a><span class="cm"> * The first call to this routine by a process with a given #GOnce</span>
<a name="line-596"></a><span class="cm"> * struct calls @func with the given argument. Thereafter, subsequent</span>
<a name="line-597"></a><span class="cm"> * calls to g_once()  with the same #GOnce struct do not call @func</span>
<a name="line-598"></a><span class="cm"> * again, but return the stored result of the first call. On return</span>
<a name="line-599"></a><span class="cm"> * from g_once(), the status of @once will be %G_ONCE_STATUS_READY.</span>
<a name="line-600"></a><span class="cm"> *</span>
<a name="line-601"></a><span class="cm"> * For example, a mutex or a thread-specific data key must be created</span>
<a name="line-602"></a><span class="cm"> * exactly once. In a threaded environment, calling g_once() ensures</span>
<a name="line-603"></a><span class="cm"> * that the initialization is serialized across multiple threads.</span>
<a name="line-604"></a><span class="cm"> *</span>
<a name="line-605"></a><span class="cm"> * Calling g_once() recursively on the same #GOnce struct in</span>
<a name="line-606"></a><span class="cm"> * @func will lead to a deadlock.</span>
<a name="line-607"></a><span class="cm"> *</span>
<a name="line-608"></a><span class="cm"> * |[&lt;!-- language=&quot;C&quot; --&gt; </span>
<a name="line-609"></a><span class="cm"> *   gpointer</span>
<a name="line-610"></a><span class="cm"> *   get_debug_flags (void)</span>
<a name="line-611"></a><span class="cm"> *   {</span>
<a name="line-612"></a><span class="cm"> *     static GOnce my_once = G_ONCE_INIT;</span>
<a name="line-613"></a><span class="cm"> *</span>
<a name="line-614"></a><span class="cm"> *     g_once (&amp;my_once, parse_debug_flags, NULL);</span>
<a name="line-615"></a><span class="cm"> *</span>
<a name="line-616"></a><span class="cm"> *     return my_once.retval;</span>
<a name="line-617"></a><span class="cm"> *   }</span>
<a name="line-618"></a><span class="cm"> * ]|</span>
<a name="line-619"></a><span class="cm"> *</span>
<a name="line-620"></a><span class="cm"> * Since: 2.4</span>
<a name="line-621"></a><span class="cm"> */</span>
<a name="line-622"></a><span class="n">gpointer</span>
<a name="line-623"></a><span class="nf">g_once_impl</span> <span class="p">(</span><span class="n">GOnce</span>       <span class="o">*</span><span class="n">once</span><span class="p">,</span>
<a name="line-624"></a>	     <span class="n">GThreadFunc</span>  <span class="n">func</span><span class="p">,</span>
<a name="line-625"></a>	     <span class="n">gpointer</span>     <span class="n">arg</span><span class="p">)</span>
<a name="line-626"></a><span class="p">{</span>
<a name="line-627"></a>  <span class="n">g_mutex_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">g_once_mutex</span><span class="p">);</span>
<a name="line-628"></a>
<a name="line-629"></a>  <span class="k">while</span> <span class="p">(</span><span class="n">once</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">G_ONCE_STATUS_PROGRESS</span><span class="p">)</span>
<a name="line-630"></a>    <span class="n">g_cond_wait</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">g_once_cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_once_mutex</span><span class="p">);</span>
<a name="line-631"></a>
<a name="line-632"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">once</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">G_ONCE_STATUS_READY</span><span class="p">)</span>
<a name="line-633"></a>    <span class="p">{</span>
<a name="line-634"></a>      <span class="n">gpointer</span> <span class="n">retval</span><span class="p">;</span>
<a name="line-635"></a>
<a name="line-636"></a>      <span class="n">once</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">G_ONCE_STATUS_PROGRESS</span><span class="p">;</span>
<a name="line-637"></a>      <span class="n">g_mutex_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">g_once_mutex</span><span class="p">);</span>
<a name="line-638"></a>
<a name="line-639"></a>      <span class="n">retval</span> <span class="o">=</span> <span class="n">func</span> <span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<a name="line-640"></a>
<a name="line-641"></a>      <span class="n">g_mutex_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">g_once_mutex</span><span class="p">);</span>
<a name="line-642"></a><span class="cm">/* We prefer the new C11-style atomic extension of GCC if available. If not,</span>
<a name="line-643"></a><span class="cm"> * fall back to always locking. */</span>
<a name="line-644"></a><span class="cp">#if defined(G_ATOMIC_LOCK_FREE) &amp;&amp; defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4) &amp;&amp; defined(__ATOMIC_SEQ_CST)</span>
<a name="line-645"></a>      <span class="cm">/* Only the second store needs to be atomic, as the two writes are related</span>
<a name="line-646"></a><span class="cm">       * by a happens-before relationship here. */</span>
<a name="line-647"></a>      <span class="n">once</span><span class="o">-&gt;</span><span class="n">retval</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
<a name="line-648"></a>      <span class="n">__atomic_store_n</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">once</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">G_ONCE_STATUS_READY</span><span class="p">,</span> <span class="n">__ATOMIC_RELEASE</span><span class="p">);</span>
<a name="line-649"></a><span class="cp">#else</span>
<a name="line-650"></a>      <span class="n">once</span><span class="o">-&gt;</span><span class="n">retval</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
<a name="line-651"></a>      <span class="n">once</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">G_ONCE_STATUS_READY</span><span class="p">;</span>
<a name="line-652"></a><span class="cp">#endif</span>
<a name="line-653"></a>      <span class="n">g_cond_broadcast</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">g_once_cond</span><span class="p">);</span>
<a name="line-654"></a>    <span class="p">}</span>
<a name="line-655"></a>
<a name="line-656"></a>  <span class="n">g_mutex_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">g_once_mutex</span><span class="p">);</span>
<a name="line-657"></a>
<a name="line-658"></a>  <span class="k">return</span> <span class="n">once</span><span class="o">-&gt;</span><span class="n">retval</span><span class="p">;</span>
<a name="line-659"></a><span class="p">}</span>
<a name="line-660"></a>
<a name="line-661"></a><span class="cm">/**</span>
<a name="line-662"></a><span class="cm"> * g_once_init_enter:</span>
<a name="line-663"></a><span class="cm"> * @location: (not nullable): location of a static initializable variable</span>
<a name="line-664"></a><span class="cm"> *    containing 0</span>
<a name="line-665"></a><span class="cm"> *</span>
<a name="line-666"></a><span class="cm"> * Function to be called when starting a critical initialization</span>
<a name="line-667"></a><span class="cm"> * section. The argument @location must point to a static</span>
<a name="line-668"></a><span class="cm"> * 0-initialized variable that will be set to a value other than 0 at</span>
<a name="line-669"></a><span class="cm"> * the end of the initialization section. In combination with</span>
<a name="line-670"></a><span class="cm"> * g_once_init_leave() and the unique address @value_location, it can</span>
<a name="line-671"></a><span class="cm"> * be ensured that an initialization section will be executed only once</span>
<a name="line-672"></a><span class="cm"> * during a program&#39;s life time, and that concurrent threads are</span>
<a name="line-673"></a><span class="cm"> * blocked until initialization completed. To be used in constructs</span>
<a name="line-674"></a><span class="cm"> * like this:</span>
<a name="line-675"></a><span class="cm"> *</span>
<a name="line-676"></a><span class="cm"> * |[&lt;!-- language=&quot;C&quot; --&gt; </span>
<a name="line-677"></a><span class="cm"> *   static gsize initialization_value = 0;</span>
<a name="line-678"></a><span class="cm"> *</span>
<a name="line-679"></a><span class="cm"> *   if (g_once_init_enter (&amp;initialization_value))</span>
<a name="line-680"></a><span class="cm"> *     {</span>
<a name="line-681"></a><span class="cm"> *       gsize setup_value = 42; // initialization code here</span>
<a name="line-682"></a><span class="cm"> *</span>
<a name="line-683"></a><span class="cm"> *       g_once_init_leave (&amp;initialization_value, setup_value);</span>
<a name="line-684"></a><span class="cm"> *     }</span>
<a name="line-685"></a><span class="cm"> *</span>
<a name="line-686"></a><span class="cm"> *   // use initialization_value here</span>
<a name="line-687"></a><span class="cm"> * ]|</span>
<a name="line-688"></a><span class="cm"> *</span>
<a name="line-689"></a><span class="cm"> * Returns: %TRUE if the initialization section should be entered,</span>
<a name="line-690"></a><span class="cm"> *     %FALSE and blocks otherwise</span>
<a name="line-691"></a><span class="cm"> *</span>
<a name="line-692"></a><span class="cm"> * Since: 2.14</span>
<a name="line-693"></a><span class="cm"> */</span>
<a name="line-694"></a><span class="n">gboolean</span>
<a name="line-695"></a><span class="p">(</span><span class="n">g_once_init_enter</span><span class="p">)</span> <span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="o">*</span><span class="n">location</span><span class="p">)</span>
<a name="line-696"></a><span class="p">{</span>
<a name="line-697"></a>  <span class="k">volatile</span> <span class="n">gsize</span> <span class="o">*</span><span class="n">value_location</span> <span class="o">=</span> <span class="n">location</span><span class="p">;</span>
<a name="line-698"></a>  <span class="n">gboolean</span> <span class="n">need_init</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
<a name="line-699"></a>  <span class="n">g_mutex_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">g_once_mutex</span><span class="p">);</span>
<a name="line-700"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">g_atomic_pointer_get</span> <span class="p">(</span><span class="n">value_location</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<a name="line-701"></a>    <span class="p">{</span>
<a name="line-702"></a>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">g_slist_find</span> <span class="p">(</span><span class="n">g_once_init_list</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">value_location</span><span class="p">))</span>
<a name="line-703"></a>        <span class="p">{</span>
<a name="line-704"></a>          <span class="n">need_init</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
<a name="line-705"></a>          <span class="n">g_once_init_list</span> <span class="o">=</span> <span class="n">g_slist_prepend</span> <span class="p">(</span><span class="n">g_once_init_list</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">value_location</span><span class="p">);</span>
<a name="line-706"></a>        <span class="p">}</span>
<a name="line-707"></a>      <span class="k">else</span>
<a name="line-708"></a>        <span class="k">do</span>
<a name="line-709"></a>          <span class="n">g_cond_wait</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">g_once_cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_once_mutex</span><span class="p">);</span>
<a name="line-710"></a>        <span class="k">while</span> <span class="p">(</span><span class="n">g_slist_find</span> <span class="p">(</span><span class="n">g_once_init_list</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">value_location</span><span class="p">));</span>
<a name="line-711"></a>    <span class="p">}</span>
<a name="line-712"></a>  <span class="n">g_mutex_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">g_once_mutex</span><span class="p">);</span>
<a name="line-713"></a>  <span class="k">return</span> <span class="n">need_init</span><span class="p">;</span>
<a name="line-714"></a><span class="p">}</span>
<a name="line-715"></a>
<a name="line-716"></a><span class="cm">/**</span>
<a name="line-717"></a><span class="cm"> * g_once_init_leave:</span>
<a name="line-718"></a><span class="cm"> * @location: (not nullable): location of a static initializable variable</span>
<a name="line-719"></a><span class="cm"> *    containing 0</span>
<a name="line-720"></a><span class="cm"> * @result: new non-0 value for *@value_location</span>
<a name="line-721"></a><span class="cm"> *</span>
<a name="line-722"></a><span class="cm"> * Counterpart to g_once_init_enter(). Expects a location of a static</span>
<a name="line-723"></a><span class="cm"> * 0-initialized initialization variable, and an initialization value</span>
<a name="line-724"></a><span class="cm"> * other than 0. Sets the variable to the initialization value, and</span>
<a name="line-725"></a><span class="cm"> * releases concurrent threads blocking in g_once_init_enter() on this</span>
<a name="line-726"></a><span class="cm"> * initialization variable.</span>
<a name="line-727"></a><span class="cm"> *</span>
<a name="line-728"></a><span class="cm"> * Since: 2.14</span>
<a name="line-729"></a><span class="cm"> */</span>
<a name="line-730"></a><span class="kt">void</span>
<a name="line-731"></a><span class="p">(</span><span class="n">g_once_init_leave</span><span class="p">)</span> <span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span>
<a name="line-732"></a>                     <span class="n">gsize</span>          <span class="n">result</span><span class="p">)</span>
<a name="line-733"></a><span class="p">{</span>
<a name="line-734"></a>  <span class="k">volatile</span> <span class="n">gsize</span> <span class="o">*</span><span class="n">value_location</span> <span class="o">=</span> <span class="n">location</span><span class="p">;</span>
<a name="line-735"></a>
<a name="line-736"></a>  <span class="n">g_return_if_fail</span> <span class="p">(</span><span class="n">g_atomic_pointer_get</span> <span class="p">(</span><span class="n">value_location</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<a name="line-737"></a>  <span class="n">g_return_if_fail</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<a name="line-738"></a>
<a name="line-739"></a>  <span class="n">g_atomic_pointer_set</span> <span class="p">(</span><span class="n">value_location</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<a name="line-740"></a>  <span class="n">g_mutex_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">g_once_mutex</span><span class="p">);</span>
<a name="line-741"></a>  <span class="n">g_return_if_fail</span> <span class="p">(</span><span class="n">g_once_init_list</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
<a name="line-742"></a>  <span class="n">g_once_init_list</span> <span class="o">=</span> <span class="n">g_slist_remove</span> <span class="p">(</span><span class="n">g_once_init_list</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">value_location</span><span class="p">);</span>
<a name="line-743"></a>  <span class="n">g_cond_broadcast</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">g_once_cond</span><span class="p">);</span>
<a name="line-744"></a>  <span class="n">g_mutex_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">g_once_mutex</span><span class="p">);</span>
<a name="line-745"></a><span class="p">}</span>
<a name="line-746"></a>
<a name="line-747"></a><span class="cm">/* GThread {{{1 -------------------------------------------------------- */</span>
<a name="line-748"></a>
<a name="line-749"></a><span class="cm">/**</span>
<a name="line-750"></a><span class="cm"> * g_thread_ref:</span>
<a name="line-751"></a><span class="cm"> * @thread: a #GThread</span>
<a name="line-752"></a><span class="cm"> *</span>
<a name="line-753"></a><span class="cm"> * Increase the reference count on @thread.</span>
<a name="line-754"></a><span class="cm"> *</span>
<a name="line-755"></a><span class="cm"> * Returns: (transfer full): a new reference to @thread</span>
<a name="line-756"></a><span class="cm"> *</span>
<a name="line-757"></a><span class="cm"> * Since: 2.32</span>
<a name="line-758"></a><span class="cm"> */</span>
<a name="line-759"></a><span class="n">GThread</span> <span class="o">*</span>
<a name="line-760"></a><span class="n">g_thread_ref</span> <span class="p">(</span><span class="n">GThread</span> <span class="o">*</span><span class="kr">thread</span><span class="p">)</span>
<a name="line-761"></a><span class="p">{</span>
<a name="line-762"></a>  <span class="n">GRealThread</span> <span class="o">*</span><span class="n">real</span> <span class="o">=</span> <span class="p">(</span><span class="n">GRealThread</span> <span class="o">*</span><span class="p">)</span> <span class="kr">thread</span><span class="p">;</span>
<a name="line-763"></a>
<a name="line-764"></a>  <span class="n">g_atomic_int_inc</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">real</span><span class="o">-&gt;</span><span class="n">ref_count</span><span class="p">);</span>
<a name="line-765"></a>
<a name="line-766"></a>  <span class="k">return</span> <span class="kr">thread</span><span class="p">;</span>
<a name="line-767"></a><span class="p">}</span>
<a name="line-768"></a>
<a name="line-769"></a><span class="cm">/**</span>
<a name="line-770"></a><span class="cm"> * g_thread_unref:</span>
<a name="line-771"></a><span class="cm"> * @thread: (transfer full): a #GThread</span>
<a name="line-772"></a><span class="cm"> *</span>
<a name="line-773"></a><span class="cm"> * Decrease the reference count on @thread, possibly freeing all</span>
<a name="line-774"></a><span class="cm"> * resources associated with it.</span>
<a name="line-775"></a><span class="cm"> *</span>
<a name="line-776"></a><span class="cm"> * Note that each thread holds a reference to its #GThread while</span>
<a name="line-777"></a><span class="cm"> * it is running, so it is safe to drop your own reference to it</span>
<a name="line-778"></a><span class="cm"> * if you don&#39;t need it anymore.</span>
<a name="line-779"></a><span class="cm"> *</span>
<a name="line-780"></a><span class="cm"> * Since: 2.32</span>
<a name="line-781"></a><span class="cm"> */</span>
<a name="line-782"></a><span class="kt">void</span>
<a name="line-783"></a><span class="n">g_thread_unref</span> <span class="p">(</span><span class="n">GThread</span> <span class="o">*</span><span class="kr">thread</span><span class="p">)</span>
<a name="line-784"></a><span class="p">{</span>
<a name="line-785"></a>  <span class="n">GRealThread</span> <span class="o">*</span><span class="n">real</span> <span class="o">=</span> <span class="p">(</span><span class="n">GRealThread</span> <span class="o">*</span><span class="p">)</span> <span class="kr">thread</span><span class="p">;</span>
<a name="line-786"></a>
<a name="line-787"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">g_atomic_int_dec_and_test</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">real</span><span class="o">-&gt;</span><span class="n">ref_count</span><span class="p">))</span>
<a name="line-788"></a>    <span class="p">{</span>
<a name="line-789"></a>      <span class="k">if</span> <span class="p">(</span><span class="n">real</span><span class="o">-&gt;</span><span class="n">ours</span><span class="p">)</span>
<a name="line-790"></a>        <span class="n">g_system_thread_free</span> <span class="p">(</span><span class="n">real</span><span class="p">);</span>
<a name="line-791"></a>      <span class="k">else</span>
<a name="line-792"></a>        <span class="nf">g_slice_free</span> <span class="p">(</span><span class="n">GRealThread</span><span class="p">,</span> <span class="n">real</span><span class="p">);</span>
<a name="line-793"></a>    <span class="p">}</span>
<a name="line-794"></a><span class="p">}</span>
<a name="line-795"></a>
<a name="line-796"></a><span class="k">static</span> <span class="kt">void</span>
<a name="line-797"></a><span class="n">g_thread_cleanup</span> <span class="p">(</span><span class="n">gpointer</span> <span class="n">data</span><span class="p">)</span>
<a name="line-798"></a><span class="p">{</span>
<a name="line-799"></a>  <span class="n">g_thread_unref</span> <span class="p">(</span><span class="n">data</span><span class="p">);</span>
<a name="line-800"></a><span class="p">}</span>
<a name="line-801"></a>
<a name="line-802"></a><span class="n">gpointer</span>
<a name="line-803"></a><span class="n">g_thread_proxy</span> <span class="p">(</span><span class="n">gpointer</span> <span class="n">data</span><span class="p">)</span>
<a name="line-804"></a><span class="p">{</span>
<a name="line-805"></a>  <span class="n">GRealThread</span><span class="o">*</span> <span class="kr">thread</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<a name="line-806"></a>
<a name="line-807"></a>  <span class="n">g_assert</span> <span class="p">(</span><span class="n">data</span><span class="p">);</span>
<a name="line-808"></a>  <span class="n">g_private_set</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">g_thread_specific_private</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<a name="line-809"></a>
<a name="line-810"></a>  <span class="n">TRACE</span> <span class="p">(</span><span class="n">GLIB_THREAD_SPAWNED</span> <span class="p">(</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">func</span><span class="p">,</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">data</span><span class="p">,</span>
<a name="line-811"></a>                              <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
<a name="line-812"></a>
<a name="line-813"></a>  <span class="k">if</span> <span class="p">(</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
<a name="line-814"></a>    <span class="p">{</span>
<a name="line-815"></a>      <span class="n">g_system_thread_set_name</span> <span class="p">(</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<a name="line-816"></a>      <span class="n">g_free</span> <span class="p">(</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<a name="line-817"></a>      <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<a name="line-818"></a>    <span class="p">}</span>
<a name="line-819"></a>
<a name="line-820"></a>  <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">retval</span> <span class="o">=</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">func</span> <span class="p">(</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
<a name="line-821"></a>
<a name="line-822"></a>  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<a name="line-823"></a><span class="p">}</span>
<a name="line-824"></a>
<a name="line-825"></a><span class="n">guint</span>
<a name="line-826"></a><span class="n">g_thread_n_created</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<a name="line-827"></a><span class="p">{</span>
<a name="line-828"></a>  <span class="k">return</span> <span class="nf">g_atomic_int_get</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">g_thread_n_created_counter</span><span class="p">);</span>
<a name="line-829"></a><span class="p">}</span>
<a name="line-830"></a>
<a name="line-831"></a><span class="cm">/**</span>
<a name="line-832"></a><span class="cm"> * g_thread_new:</span>
<a name="line-833"></a><span class="cm"> * @name: (nullable): an (optional) name for the new thread</span>
<a name="line-834"></a><span class="cm"> * @func: (closure data) (scope async): a function to execute in the new thread</span>
<a name="line-835"></a><span class="cm"> * @data: (nullable): an argument to supply to the new thread</span>
<a name="line-836"></a><span class="cm"> *</span>
<a name="line-837"></a><span class="cm"> * This function creates a new thread. The new thread starts by invoking</span>
<a name="line-838"></a><span class="cm"> * @func with the argument data. The thread will run until @func returns</span>
<a name="line-839"></a><span class="cm"> * or until g_thread_exit() is called from the new thread. The return value</span>
<a name="line-840"></a><span class="cm"> * of @func becomes the return value of the thread, which can be obtained</span>
<a name="line-841"></a><span class="cm"> * with g_thread_join().</span>
<a name="line-842"></a><span class="cm"> *</span>
<a name="line-843"></a><span class="cm"> * The @name can be useful for discriminating threads in a debugger.</span>
<a name="line-844"></a><span class="cm"> * It is not used for other purposes and does not have to be unique.</span>
<a name="line-845"></a><span class="cm"> * Some systems restrict the length of @name to 16 bytes.</span>
<a name="line-846"></a><span class="cm"> *</span>
<a name="line-847"></a><span class="cm"> * If the thread can not be created the program aborts. See</span>
<a name="line-848"></a><span class="cm"> * g_thread_try_new() if you want to attempt to deal with failures.</span>
<a name="line-849"></a><span class="cm"> *</span>
<a name="line-850"></a><span class="cm"> * If you are using threads to offload (potentially many) short-lived tasks,</span>
<a name="line-851"></a><span class="cm"> * #GThreadPool may be more appropriate than manually spawning and tracking</span>
<a name="line-852"></a><span class="cm"> * multiple #GThreads.</span>
<a name="line-853"></a><span class="cm"> *</span>
<a name="line-854"></a><span class="cm"> * To free the struct returned by this function, use g_thread_unref().</span>
<a name="line-855"></a><span class="cm"> * Note that g_thread_join() implicitly unrefs the #GThread as well.</span>
<a name="line-856"></a><span class="cm"> *</span>
<a name="line-857"></a><span class="cm"> * New threads by default inherit their scheduler policy (POSIX) or thread</span>
<a name="line-858"></a><span class="cm"> * priority (Windows) of the thread creating the new thread.</span>
<a name="line-859"></a><span class="cm"> *</span>
<a name="line-860"></a><span class="cm"> * This behaviour changed in GLib 2.64: before threads on Windows were not</span>
<a name="line-861"></a><span class="cm"> * inheriting the thread priority but were spawned with the default priority.</span>
<a name="line-862"></a><span class="cm"> * Starting with GLib 2.64 the behaviour is now consistent between Windows and</span>
<a name="line-863"></a><span class="cm"> * POSIX and all threads inherit their parent thread&#39;s priority.</span>
<a name="line-864"></a><span class="cm"> *</span>
<a name="line-865"></a><span class="cm"> * Returns: (transfer full): the new #GThread</span>
<a name="line-866"></a><span class="cm"> *</span>
<a name="line-867"></a><span class="cm"> * Since: 2.32</span>
<a name="line-868"></a><span class="cm"> */</span>
<a name="line-869"></a><span class="n">GThread</span> <span class="o">*</span>
<a name="line-870"></a><span class="n">g_thread_new</span> <span class="p">(</span><span class="k">const</span> <span class="n">gchar</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
<a name="line-871"></a>              <span class="n">GThreadFunc</span>  <span class="n">func</span><span class="p">,</span>
<a name="line-872"></a>              <span class="n">gpointer</span>     <span class="n">data</span><span class="p">)</span>
<a name="line-873"></a><span class="p">{</span>
<a name="line-874"></a>  <span class="n">GError</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<a name="line-875"></a>  <span class="n">GThread</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>
<a name="line-876"></a>
<a name="line-877"></a>  <span class="kr">thread</span> <span class="o">=</span> <span class="n">g_thread_new_internal</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">g_thread_proxy</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">);</span>
<a name="line-878"></a>
<a name="line-879"></a>  <span class="k">if</span> <span class="nf">G_UNLIKELY</span> <span class="p">(</span><span class="kr">thread</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
<a name="line-880"></a>    <span class="n">g_error</span> <span class="p">(</span><span class="s">&quot;creating thread &#39;%s&#39;: %s&quot;</span><span class="p">,</span> <span class="n">name</span> <span class="o">?</span> <span class="nl">name</span> <span class="p">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">error</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">);</span>
<a name="line-881"></a>
<a name="line-882"></a>  <span class="k">return</span> <span class="kr">thread</span><span class="p">;</span>
<a name="line-883"></a><span class="p">}</span>
<a name="line-884"></a>
<a name="line-885"></a><span class="cm">/**</span>
<a name="line-886"></a><span class="cm"> * g_thread_try_new:</span>
<a name="line-887"></a><span class="cm"> * @name: (nullable): an (optional) name for the new thread</span>
<a name="line-888"></a><span class="cm"> * @func: (closure data) (scope async): a function to execute in the new thread</span>
<a name="line-889"></a><span class="cm"> * @data: (nullable): an argument to supply to the new thread</span>
<a name="line-890"></a><span class="cm"> * @error: return location for error, or %NULL</span>
<a name="line-891"></a><span class="cm"> *</span>
<a name="line-892"></a><span class="cm"> * This function is the same as g_thread_new() except that</span>
<a name="line-893"></a><span class="cm"> * it allows for the possibility of failure.</span>
<a name="line-894"></a><span class="cm"> *</span>
<a name="line-895"></a><span class="cm"> * If a thread can not be created (due to resource limits),</span>
<a name="line-896"></a><span class="cm"> * @error is set and %NULL is returned.</span>
<a name="line-897"></a><span class="cm"> *</span>
<a name="line-898"></a><span class="cm"> * Returns: (transfer full): the new #GThread, or %NULL if an error occurred</span>
<a name="line-899"></a><span class="cm"> *</span>
<a name="line-900"></a><span class="cm"> * Since: 2.32</span>
<a name="line-901"></a><span class="cm"> */</span>
<a name="line-902"></a><span class="n">GThread</span> <span class="o">*</span>
<a name="line-903"></a><span class="n">g_thread_try_new</span> <span class="p">(</span><span class="k">const</span> <span class="n">gchar</span>  <span class="o">*</span><span class="n">name</span><span class="p">,</span>
<a name="line-904"></a>                  <span class="n">GThreadFunc</span>   <span class="n">func</span><span class="p">,</span>
<a name="line-905"></a>                  <span class="n">gpointer</span>      <span class="n">data</span><span class="p">,</span>
<a name="line-906"></a>                  <span class="n">GError</span>      <span class="o">**</span><span class="n">error</span><span class="p">)</span>
<a name="line-907"></a><span class="p">{</span>
<a name="line-908"></a>  <span class="k">return</span> <span class="nf">g_thread_new_internal</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">g_thread_proxy</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<a name="line-909"></a><span class="p">}</span>
<a name="line-910"></a>
<a name="line-911"></a><span class="n">GThread</span> <span class="o">*</span>
<a name="line-912"></a><span class="n">g_thread_new_internal</span> <span class="p">(</span><span class="k">const</span> <span class="n">gchar</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
<a name="line-913"></a>                       <span class="n">GThreadFunc</span> <span class="n">proxy</span><span class="p">,</span>
<a name="line-914"></a>                       <span class="n">GThreadFunc</span> <span class="n">func</span><span class="p">,</span>
<a name="line-915"></a>                       <span class="n">gpointer</span> <span class="n">data</span><span class="p">,</span>
<a name="line-916"></a>                       <span class="n">gsize</span> <span class="n">stack_size</span><span class="p">,</span>
<a name="line-917"></a>                       <span class="k">const</span> <span class="n">GThreadSchedulerSettings</span> <span class="o">*</span><span class="n">scheduler_settings</span><span class="p">,</span>
<a name="line-918"></a>                       <span class="n">GError</span> <span class="o">**</span><span class="n">error</span><span class="p">)</span>
<a name="line-919"></a><span class="p">{</span>
<a name="line-920"></a>  <span class="n">g_return_val_if_fail</span> <span class="p">(</span><span class="n">func</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<a name="line-921"></a>
<a name="line-922"></a>  <span class="n">g_atomic_int_inc</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">g_thread_n_created_counter</span><span class="p">);</span>
<a name="line-923"></a>
<a name="line-924"></a>  <span class="n">g_trace_mark</span> <span class="p">(</span><span class="n">G_TRACE_CURRENT_TIME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;GLib&quot;</span><span class="p">,</span> <span class="s">&quot;GThread created&quot;</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">name</span> <span class="o">?</span> <span class="nl">name</span> <span class="p">:</span> <span class="s">&quot;(unnamed)&quot;</span><span class="p">);</span>
<a name="line-925"></a>  <span class="k">return</span> <span class="p">(</span><span class="n">GThread</span> <span class="o">*</span><span class="p">)</span> <span class="n">g_system_thread_new</span> <span class="p">(</span><span class="n">proxy</span><span class="p">,</span> <span class="n">stack_size</span><span class="p">,</span> <span class="n">scheduler_settings</span><span class="p">,</span>
<a name="line-926"></a>                                          <span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<a name="line-927"></a><span class="p">}</span>
<a name="line-928"></a>
<a name="line-929"></a><span class="n">gboolean</span>
<a name="line-930"></a><span class="n">g_thread_get_scheduler_settings</span> <span class="p">(</span><span class="n">GThreadSchedulerSettings</span> <span class="o">*</span><span class="n">scheduler_settings</span><span class="p">)</span>
<a name="line-931"></a><span class="p">{</span>
<a name="line-932"></a>  <span class="n">g_return_val_if_fail</span> <span class="p">(</span><span class="n">scheduler_settings</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
<a name="line-933"></a>
<a name="line-934"></a>  <span class="k">return</span> <span class="nf">g_system_thread_get_scheduler_settings</span> <span class="p">(</span><span class="n">scheduler_settings</span><span class="p">);</span>
<a name="line-935"></a><span class="p">}</span>
<a name="line-936"></a>
<a name="line-937"></a><span class="cm">/**</span>
<a name="line-938"></a><span class="cm"> * g_thread_exit:</span>
<a name="line-939"></a><span class="cm"> * @retval: the return value of this thread</span>
<a name="line-940"></a><span class="cm"> *</span>
<a name="line-941"></a><span class="cm"> * Terminates the current thread.</span>
<a name="line-942"></a><span class="cm"> *</span>
<a name="line-943"></a><span class="cm"> * If another thread is waiting for us using g_thread_join() then the</span>
<a name="line-944"></a><span class="cm"> * waiting thread will be woken up and get @retval as the return value</span>
<a name="line-945"></a><span class="cm"> * of g_thread_join().</span>
<a name="line-946"></a><span class="cm"> *</span>
<a name="line-947"></a><span class="cm"> * Calling g_thread_exit() with a parameter @retval is equivalent to</span>
<a name="line-948"></a><span class="cm"> * returning @retval from the function @func, as given to g_thread_new().</span>
<a name="line-949"></a><span class="cm"> *</span>
<a name="line-950"></a><span class="cm"> * You must only call g_thread_exit() from a thread that you created</span>
<a name="line-951"></a><span class="cm"> * yourself with g_thread_new() or related APIs. You must not call</span>
<a name="line-952"></a><span class="cm"> * this function from a thread created with another threading library</span>
<a name="line-953"></a><span class="cm"> * or or from within a #GThreadPool.</span>
<a name="line-954"></a><span class="cm"> */</span>
<a name="line-955"></a><span class="kt">void</span>
<a name="line-956"></a><span class="n">g_thread_exit</span> <span class="p">(</span><span class="n">gpointer</span> <span class="n">retval</span><span class="p">)</span>
<a name="line-957"></a><span class="p">{</span>
<a name="line-958"></a>  <span class="n">GRealThread</span><span class="o">*</span> <span class="n">real</span> <span class="o">=</span> <span class="p">(</span><span class="n">GRealThread</span><span class="o">*</span><span class="p">)</span> <span class="n">g_thread_self</span> <span class="p">();</span>
<a name="line-959"></a>
<a name="line-960"></a>  <span class="k">if</span> <span class="nf">G_UNLIKELY</span> <span class="p">(</span><span class="o">!</span><span class="n">real</span><span class="o">-&gt;</span><span class="n">ours</span><span class="p">)</span>
<a name="line-961"></a>    <span class="n">g_error</span> <span class="p">(</span><span class="s">&quot;attempt to g_thread_exit() a thread not created by GLib&quot;</span><span class="p">);</span>
<a name="line-962"></a>
<a name="line-963"></a>  <span class="n">real</span><span class="o">-&gt;</span><span class="n">retval</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
<a name="line-964"></a>
<a name="line-965"></a>  <span class="n">g_system_thread_exit</span> <span class="p">();</span>
<a name="line-966"></a><span class="p">}</span>
<a name="line-967"></a>
<a name="line-968"></a><span class="cm">/**</span>
<a name="line-969"></a><span class="cm"> * g_thread_join:</span>
<a name="line-970"></a><span class="cm"> * @thread: (transfer full): a #GThread</span>
<a name="line-971"></a><span class="cm"> *</span>
<a name="line-972"></a><span class="cm"> * Waits until @thread finishes, i.e. the function @func, as</span>
<a name="line-973"></a><span class="cm"> * given to g_thread_new(), returns or g_thread_exit() is called.</span>
<a name="line-974"></a><span class="cm"> * If @thread has already terminated, then g_thread_join()</span>
<a name="line-975"></a><span class="cm"> * returns immediately.</span>
<a name="line-976"></a><span class="cm"> *</span>
<a name="line-977"></a><span class="cm"> * Any thread can wait for any other thread by calling g_thread_join(),</span>
<a name="line-978"></a><span class="cm"> * not just its &#39;creator&#39;. Calling g_thread_join() from multiple threads</span>
<a name="line-979"></a><span class="cm"> * for the same @thread leads to undefined behaviour.</span>
<a name="line-980"></a><span class="cm"> *</span>
<a name="line-981"></a><span class="cm"> * The value returned by @func or given to g_thread_exit() is</span>
<a name="line-982"></a><span class="cm"> * returned by this function.</span>
<a name="line-983"></a><span class="cm"> *</span>
<a name="line-984"></a><span class="cm"> * g_thread_join() consumes the reference to the passed-in @thread.</span>
<a name="line-985"></a><span class="cm"> * This will usually cause the #GThread struct and associated resources</span>
<a name="line-986"></a><span class="cm"> * to be freed. Use g_thread_ref() to obtain an extra reference if you</span>
<a name="line-987"></a><span class="cm"> * want to keep the GThread alive beyond the g_thread_join() call.</span>
<a name="line-988"></a><span class="cm"> *</span>
<a name="line-989"></a><span class="cm"> * Returns: (transfer full): the return value of the thread</span>
<a name="line-990"></a><span class="cm"> */</span>
<a name="line-991"></a><span class="n">gpointer</span>
<a name="line-992"></a><span class="n">g_thread_join</span> <span class="p">(</span><span class="n">GThread</span> <span class="o">*</span><span class="kr">thread</span><span class="p">)</span>
<a name="line-993"></a><span class="p">{</span>
<a name="line-994"></a>  <span class="n">GRealThread</span> <span class="o">*</span><span class="n">real</span> <span class="o">=</span> <span class="p">(</span><span class="n">GRealThread</span><span class="o">*</span><span class="p">)</span> <span class="kr">thread</span><span class="p">;</span>
<a name="line-995"></a>  <span class="n">gpointer</span> <span class="n">retval</span><span class="p">;</span>
<a name="line-996"></a>
<a name="line-997"></a>  <span class="n">g_return_val_if_fail</span> <span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<a name="line-998"></a>  <span class="n">g_return_val_if_fail</span> <span class="p">(</span><span class="n">real</span><span class="o">-&gt;</span><span class="n">ours</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<a name="line-999"></a>
<a name="line-1000"></a>  <span class="n">g_system_thread_wait</span> <span class="p">(</span><span class="n">real</span><span class="p">);</span>
<a name="line-1001"></a>
<a name="line-1002"></a>  <span class="n">retval</span> <span class="o">=</span> <span class="n">real</span><span class="o">-&gt;</span><span class="n">retval</span><span class="p">;</span>
<a name="line-1003"></a>
<a name="line-1004"></a>  <span class="cm">/* Just to make sure, this isn&#39;t used any more */</span>
<a name="line-1005"></a>  <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">joinable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-1006"></a>
<a name="line-1007"></a>  <span class="n">g_thread_unref</span> <span class="p">(</span><span class="kr">thread</span><span class="p">);</span>
<a name="line-1008"></a>
<a name="line-1009"></a>  <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<a name="line-1010"></a><span class="p">}</span>
<a name="line-1011"></a>
<a name="line-1012"></a><span class="cm">/**</span>
<a name="line-1013"></a><span class="cm"> * g_thread_self:</span>
<a name="line-1014"></a><span class="cm"> *</span>
<a name="line-1015"></a><span class="cm"> * This function returns the #GThread corresponding to the</span>
<a name="line-1016"></a><span class="cm"> * current thread. Note that this function does not increase</span>
<a name="line-1017"></a><span class="cm"> * the reference count of the returned struct.</span>
<a name="line-1018"></a><span class="cm"> *</span>
<a name="line-1019"></a><span class="cm"> * This function will return a #GThread even for threads that</span>
<a name="line-1020"></a><span class="cm"> * were not created by GLib (i.e. those created by other threading</span>
<a name="line-1021"></a><span class="cm"> * APIs). This may be useful for thread identification purposes</span>
<a name="line-1022"></a><span class="cm"> * (i.e. comparisons) but you must not use GLib functions (such</span>
<a name="line-1023"></a><span class="cm"> * as g_thread_join()) on these threads.</span>
<a name="line-1024"></a><span class="cm"> *</span>
<a name="line-1025"></a><span class="cm"> * Returns: (transfer none): the #GThread representing the current thread</span>
<a name="line-1026"></a><span class="cm"> */</span>
<a name="line-1027"></a><span class="n">GThread</span><span class="o">*</span>
<a name="line-1028"></a><span class="n">g_thread_self</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<a name="line-1029"></a><span class="p">{</span>
<a name="line-1030"></a>  <span class="n">GRealThread</span><span class="o">*</span> <span class="kr">thread</span> <span class="o">=</span> <span class="n">g_private_get</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">g_thread_specific_private</span><span class="p">);</span>
<a name="line-1031"></a>
<a name="line-1032"></a>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="kr">thread</span><span class="p">)</span>
<a name="line-1033"></a>    <span class="p">{</span>
<a name="line-1034"></a>      <span class="cm">/* If no thread data is available, provide and set one.</span>
<a name="line-1035"></a><span class="cm">       * This can happen for the main thread and for threads</span>
<a name="line-1036"></a><span class="cm">       * that are not created by GLib.</span>
<a name="line-1037"></a><span class="cm">       */</span>
<a name="line-1038"></a>      <span class="kr">thread</span> <span class="o">=</span> <span class="n">g_slice_new0</span> <span class="p">(</span><span class="n">GRealThread</span><span class="p">);</span>
<a name="line-1039"></a>      <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">ref_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-1040"></a>
<a name="line-1041"></a>      <span class="n">g_private_set</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">g_thread_specific_private</span><span class="p">,</span> <span class="kr">thread</span><span class="p">);</span>
<a name="line-1042"></a>    <span class="p">}</span>
<a name="line-1043"></a>
<a name="line-1044"></a>  <span class="k">return</span> <span class="p">(</span><span class="n">GThread</span><span class="o">*</span><span class="p">)</span> <span class="kr">thread</span><span class="p">;</span>
<a name="line-1045"></a><span class="p">}</span>
<a name="line-1046"></a>
<a name="line-1047"></a><span class="cm">/**</span>
<a name="line-1048"></a><span class="cm"> * g_get_num_processors:</span>
<a name="line-1049"></a><span class="cm"> *</span>
<a name="line-1050"></a><span class="cm"> * Determine the approximate number of threads that the system will</span>
<a name="line-1051"></a><span class="cm"> * schedule simultaneously for this process.  This is intended to be</span>
<a name="line-1052"></a><span class="cm"> * used as a parameter to g_thread_pool_new() for CPU bound tasks and</span>
<a name="line-1053"></a><span class="cm"> * similar cases.</span>
<a name="line-1054"></a><span class="cm"> *</span>
<a name="line-1055"></a><span class="cm"> * Returns: Number of schedulable threads, always greater than 0</span>
<a name="line-1056"></a><span class="cm"> *</span>
<a name="line-1057"></a><span class="cm"> * Since: 2.36</span>
<a name="line-1058"></a><span class="cm"> */</span>
<a name="line-1059"></a><span class="n">guint</span>
<a name="line-1060"></a><span class="n">g_get_num_processors</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<a name="line-1061"></a><span class="p">{</span>
<a name="line-1062"></a><span class="cp">#ifdef G_OS_WIN32</span>
<a name="line-1063"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<a name="line-1064"></a>  <span class="n">SYSTEM_INFO</span> <span class="n">sysinfo</span><span class="p">;</span>
<a name="line-1065"></a>  <span class="n">DWORD_PTR</span> <span class="n">process_cpus</span><span class="p">;</span>
<a name="line-1066"></a>  <span class="n">DWORD_PTR</span> <span class="n">system_cpus</span><span class="p">;</span>
<a name="line-1067"></a>
<a name="line-1068"></a>  <span class="cm">/* This *never* fails, use it as fallback */</span>
<a name="line-1069"></a>  <span class="n">GetNativeSystemInfo</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">sysinfo</span><span class="p">);</span>
<a name="line-1070"></a>  <span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">sysinfo</span><span class="p">.</span><span class="n">dwNumberOfProcessors</span><span class="p">;</span>
<a name="line-1071"></a>
<a name="line-1072"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">GetProcessAffinityMask</span> <span class="p">(</span><span class="n">GetCurrentProcess</span> <span class="p">(),</span>
<a name="line-1073"></a>                              <span class="o">&amp;</span><span class="n">process_cpus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">system_cpus</span><span class="p">))</span>
<a name="line-1074"></a>    <span class="p">{</span>
<a name="line-1075"></a>      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">af_count</span><span class="p">;</span>
<a name="line-1076"></a>
<a name="line-1077"></a>      <span class="k">for</span> <span class="p">(</span><span class="n">af_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">process_cpus</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">process_cpus</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span>
<a name="line-1078"></a>        <span class="k">if</span> <span class="p">(</span><span class="n">process_cpus</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
<a name="line-1079"></a>          <span class="n">af_count</span><span class="o">++</span><span class="p">;</span>
<a name="line-1080"></a>
<a name="line-1081"></a>      <span class="cm">/* Prefer affinity-based result, if available */</span>
<a name="line-1082"></a>      <span class="k">if</span> <span class="p">(</span><span class="n">af_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<a name="line-1083"></a>        <span class="n">count</span> <span class="o">=</span> <span class="n">af_count</span><span class="p">;</span>
<a name="line-1084"></a>    <span class="p">}</span>
<a name="line-1085"></a>
<a name="line-1086"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<a name="line-1087"></a>    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<a name="line-1088"></a><span class="cp">#elif defined(_SC_NPROCESSORS_ONLN)</span>
<a name="line-1089"></a>  <span class="p">{</span>
<a name="line-1090"></a>    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<a name="line-1091"></a>
<a name="line-1092"></a>    <span class="n">count</span> <span class="o">=</span> <span class="n">sysconf</span> <span class="p">(</span><span class="n">_SC_NPROCESSORS_ONLN</span><span class="p">);</span>
<a name="line-1093"></a>    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<a name="line-1094"></a>      <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<a name="line-1095"></a>  <span class="p">}</span>
<a name="line-1096"></a><span class="cp">#elif defined HW_NCPU</span>
<a name="line-1097"></a>  <span class="p">{</span>
<a name="line-1098"></a>    <span class="kt">int</span> <span class="n">mib</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-1099"></a>    <span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
<a name="line-1100"></a>
<a name="line-1101"></a>    <span class="n">mib</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CTL_HW</span><span class="p">;</span>
<a name="line-1102"></a>    <span class="n">mib</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">HW_NCPU</span><span class="p">;</span>
<a name="line-1103"></a>    <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
<a name="line-1104"></a>
<a name="line-1105"></a>    <span class="k">if</span> <span class="p">(</span><span class="n">sysctl</span> <span class="p">(</span><span class="n">mib</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<a name="line-1106"></a>      <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<a name="line-1107"></a>  <span class="p">}</span>
<a name="line-1108"></a><span class="cp">#endif</span>
<a name="line-1109"></a>
<a name="line-1110"></a>  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Fallback */</span>
<a name="line-1111"></a><span class="p">}</span>
<a name="line-1112"></a>
<a name="line-1113"></a><span class="cm">/* Epilogue {{{1 */</span>
<a name="line-1114"></a><span class="cm">/* vim: set foldmethod=marker: */</span>
</pre></div>
</td></tr></table>
      </div> <!-- /.wrapper -->
    </div>
    <div id="footer" class="footer">
      <p>
        Cppcheck 2.3 - a tool for static C/C++ code analysis<br>
        <br>
        Internet: <a href="http://cppcheck.net">http://cppcheck.net</a><br>
        IRC: <a href="irc://irc.freenode.net/cppcheck">irc://irc.freenode.net/cppcheck</a><br>
      </p>
    </div>
  </body>
</html>
